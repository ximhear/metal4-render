//
//  Renderer.swift
//  Metal4Render
//
//  Metal 4 기반 3D 렌더링 엔진
//
//  이 파일은 Metal 4 API를 사용하여 왼손 좌표계(Left-Hand Coordinate System)와
//  원근 투영(Perspective Projection)을 구현한 렌더러를 포함합니다.
//
//
//  ╔═════════════════════════════════════════════════════════════════════════════╗
//  ║                                                                             ║
//  ║                    M E T A L   완 전 가 이 드                                 ║
//  ║                    기초부터 Metal 4까지                                       ║
//  ║                                                                             ║
//  ╚═════════════════════════════════════════════════════════════════════════════╝
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제1장: Metal이란 무엇인가?
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal은 Apple이 2014년 WWDC에서 발표한 저수준(Low-Level) 그래픽 및 컴퓨팅 API입니다.
//  OpenGL ES를 대체하며, GPU의 성능을 최대한 활용할 수 있도록 설계되었습니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                           API 추상화 수준 비교                                │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   높은 추상화  ┌─────────────────────────────────────────────────────┐      │
//  │   (사용 쉬움)  │  SceneKit, SpriteKit, RealityKit                    │      │
//  │               │  (씬 그래프 기반, 자동 렌더링)                         │      │
//  │               └─────────────────────────────────────────────────────┘      │
//  │                                      │                                      │
//  │                                      ▼                                      │
//  │               ┌─────────────────────────────────────────────────────┐      │
//  │               │  Core Animation, Core Graphics                       │      │
//  │               │  (2D 그래픽, UI 렌더링)                               │      │
//  │               └─────────────────────────────────────────────────────┘      │
//  │                                      │                                      │
//  │                                      ▼                                      │
//  │               ┌─────────────────────────────────────────────────────┐      │
//  │               │  Metal Performance Shaders (MPS)                     │      │
//  │               │  (최적화된 이미지 처리, 행렬 연산)                     │      │
//  │               └─────────────────────────────────────────────────────┘      │
//  │                                      │                                      │
//  │                                      ▼                                      │
//  │   낮은 추상화  ┌─────────────────────────────────────────────────────┐      │
//  │   (제어 많음)  │  Metal / Metal 4                                     │      │
//  │               │  (직접 GPU 제어, 최고 성능)                           │      │
//  │               └─────────────────────────────────────────────────────┘      │
//  │                                      │                                      │
//  │                                      ▼                                      │
//  │               ┌─────────────────────────────────────────────────────┐      │
//  │               │  GPU Hardware (Apple Silicon)                        │      │
//  │               │  M1, M2, M3, M4, A-series chips                      │      │
//  │               └─────────────────────────────────────────────────────┘      │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  Metal의 주요 특징:
//  ─────────────────────────────────────────────────────────────────────────────
//  1. 저수준 접근: GPU 하드웨어에 가까운 수준의 제어
//  2. 낮은 오버헤드: 드라이버 오버헤드 최소화로 높은 성능
//  3. 사전 컴파일된 셰이더: 런타임 셰이더 컴파일 오버헤드 제거
//  4. 통합 메모리 아키텍처: Apple Silicon에서 CPU/GPU 메모리 공유
//  5. 멀티스레딩 지원: 병렬 커맨드 인코딩
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제2장: GPU 아키텍처의 이해
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  GPU(Graphics Processing Unit)는 CPU와 완전히 다른 아키텍처를 가집니다.
//  수천 개의 작은 코어가 동일한 작업을 병렬로 수행하도록 설계되었습니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                        CPU vs GPU 아키텍처 비교                               │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   CPU (Central Processing Unit)                                             │
//  │   ─────────────────────────────────                                         │
//  │   • 몇 개의 강력한 코어 (4~16개)                                              │
//  │   • 순차적 실행에 최적화                                                      │
//  │   • 복잡한 분기 예측, 캐시 계층                                               │
//  │   • 범용 연산에 적합                                                          │
//  │                                                                             │
//  │   ┌────┬────┬────┬────┐                                                    │
//  │   │Core│Core│Core│Core│  ← 각 코어가 강력하고 독립적                         │
//  │   │ 1  │ 2  │ 3  │ 4  │                                                    │
//  │   └────┴────┴────┴────┘                                                    │
//  │                                                                             │
//  │   GPU (Graphics Processing Unit)                                            │
//  │   ─────────────────────────────────                                         │
//  │   • 수천 개의 작은 코어                                                       │
//  │   • 병렬 실행에 최적화 (SIMD)                                                 │
//  │   • 동일한 연산을 많은 데이터에 수행                                           │
//  │   • 그래픽, 행렬 연산에 최적                                                  │
//  │                                                                             │
//  │   ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐                       │
//  │   │░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│░│  ← 수천 개의 작은 코어   │
//  │   └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘                       │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  Apple Silicon의 통합 메모리 아키텍처 (UMA):
//  ─────────────────────────────────────────────────────────────────────────────
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                        Apple Silicon 메모리 구조                              │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   기존 시스템 (분리된 메모리):                                                │
//  │   ───────────────────────────                                               │
//  │   ┌─────────┐          ┌─────────┐                                         │
//  │   │   CPU   │          │   GPU   │                                         │
//  │   └────┬────┘          └────┬────┘                                         │
//  │        │                    │                                               │
//  │        ▼                    ▼                                               │
//  │   ┌─────────┐          ┌─────────┐                                         │
//  │   │System   │  ◀═══▶   │  Video  │  ← 데이터 복사 필요 (느림)               │
//  │   │ Memory  │  복사    │  Memory │                                         │
//  │   │ (RAM)   │          │ (VRAM)  │                                         │
//  │   └─────────┘          └─────────┘                                         │
//  │                                                                             │
//  │   Apple Silicon (통합 메모리):                                               │
//  │   ────────────────────────────                                               │
//  │   ┌─────────────────────────────┐                                          │
//  │   │         Apple Silicon        │                                          │
//  │   │   ┌─────────┐ ┌─────────┐   │                                          │
//  │   │   │   CPU   │ │   GPU   │   │                                          │
//  │   │   └────┬────┘ └────┬────┘   │                                          │
//  │   │        │           │        │                                          │
//  │   │        └─────┬─────┘        │                                          │
//  │   │              ▼              │                                          │
//  │   │   ┌─────────────────────┐   │                                          │
//  │   │   │   Unified Memory    │   │  ← CPU/GPU가 같은 메모리 공유            │
//  │   │   │   (통합 메모리)       │   │    복사 불필요, 즉시 접근               │
//  │   │   └─────────────────────┘   │                                          │
//  │   └─────────────────────────────┘                                          │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  이 통합 메모리 덕분에 Metal에서 .storageModeShared를 사용하면
//  CPU와 GPU가 동일한 버퍼에 접근할 수 있습니다. 데이터 복사가 필요 없습니다.
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제3장: 렌더링 파이프라인 심화
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  렌더링 파이프라인은 3D 데이터가 2D 이미지로 변환되는 일련의 단계입니다.
//  Metal은 이 파이프라인의 여러 단계를 프로그래밍할 수 있게 해줍니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                        GPU 렌더링 파이프라인 전체 흐름                         │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │  ┌──────────────────┐                                                      │
//  │  │  1. 애플리케이션   │  CPU에서 실행                                         │
//  │  │     단계          │  • 씬 그래프 업데이트                                  │
//  │  │                   │  • 변환 행렬 계산                                      │
//  │  │                   │  • 버퍼 업데이트                                       │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  2. 버텍스 페칭   │  GPU 입력                                             │
//  │  │     단계          │  • 버텍스 버퍼에서 데이터 읽기                          │
//  │  │                   │  • 인덱스 버퍼 처리 (인덱스드 드로잉)                   │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ╔══════════════════╗                                                      │
//  │  ║  3. 버텍스 셰이더 ║  ★ 프로그래밍 가능 (Shaders.metal)                     │
//  │  ║     (Vertex)     ║  • 각 버텍스마다 실행                                   │
//  │  ║                  ║  • 좌표 변환 (MVP)                                      │
//  │  ║                  ║  • 조명 계산 (버텍스 라이팅)                             │
//  │  ╚════════╤═════════╝                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  4. 프리미티브    │  고정 기능                                            │
//  │  │     어셈블리      │  • 버텍스를 프리미티브로 조립                           │
//  │  │                  │  • Triangle, Line, Point                              │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  5. 클리핑        │  고정 기능                                            │
//  │  │                  │  • 뷰 프러스텀 밖 지오메트리 제거                        │
//  │  │                  │  • NDC 변환                                            │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  6. 뷰포트 변환   │  고정 기능                                            │
//  │  │                  │  • NDC → 스크린 좌표                                   │
//  │  │                  │  • 깊이 값 스케일링                                     │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  7. 래스터화      │  고정 기능                                            │
//  │  │  (Rasterization) │  • 프리미티브 → 프래그먼트                             │
//  │  │                  │  • 버텍스 속성 보간                                     │
//  │  │                  │  • Face Culling (뒷면 제거)                            │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ╔══════════════════╗                                                      │
//  │  ║  8. 프래그먼트    ║  ★ 프로그래밍 가능 (Shaders.metal)                     │
//  │  ║     셰이더       ║  • 각 프래그먼트(픽셀 후보)마다 실행                     │
//  │  ║   (Fragment)    ║  • 텍스처 샘플링                                        │
//  │  ║                  ║  • 조명 계산 (픽셀 라이팅)                              │
//  │  ║                  ║  • 최종 색상 결정                                       │
//  │  ╚════════╤═════════╝                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  9. 프래그먼트    │  고정 기능 (설정 가능)                                 │
//  │  │     테스트       │  • 깊이 테스트 (Depth Test)                            │
//  │  │                  │  • 스텐실 테스트 (Stencil Test)                        │
//  │  │                  │  • 알파 테스트                                          │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  10. 블렌딩      │  고정 기능 (설정 가능)                                  │
//  │  │                  │  • 알파 블렌딩 (투명도)                                 │
//  │  │                  │  • 소스/대상 블렌드 팩터                                │
//  │  └────────┬─────────┘                                                      │
//  │           │                                                                 │
//  │           ▼                                                                 │
//  │  ┌──────────────────┐                                                      │
//  │  │  11. 프레임버퍼   │  출력                                                 │
//  │  │      출력        │  • Color Attachment (색상)                            │
//  │  │                  │  • Depth Attachment (깊이)                            │
//  │  │                  │  • Stencil Attachment (스텐실)                        │
//  │  └──────────────────┘                                                      │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  좌표 공간 변환 상세:
//  ─────────────────────────────────────────────────────────────────────────────
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                           좌표 공간 변환 과정                                 │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │  1. 로컬 공간 (Local/Object Space)                                          │
//  │     ─────────────────────────────                                           │
//  │     • 모델 자체의 좌표계                                                     │
//  │     • 원점이 모델의 중심                                                     │
//  │     • 예: 삼각형 버텍스 (-0.5, -0.5, 0), (0.5, -0.5, 0), (0, 0.5, 0)        │
//  │                                                                             │
//  │         ┌───────────────┐                                                  │
//  │         │       ▲       │                                                  │
//  │         │      ╱ ╲      │  Y                                               │
//  │         │     ╱   ╲     │  │                                               │
//  │         │    ╱     ╲    │  └── X                                           │
//  │         │   ▼───────▼   │                                                  │
//  │         │  (-0.5) (0.5) │                                                  │
//  │         └───────────────┘                                                  │
//  │                    │                                                        │
//  │                    │ × Model Matrix (회전, 이동, 스케일)                     │
//  │                    ▼                                                        │
//  │  2. 월드 공간 (World Space)                                                 │
//  │     ──────────────────────                                                  │
//  │     • 전체 씬의 좌표계                                                       │
//  │     • 모든 오브젝트가 이 공간에 배치됨                                        │
//  │     • 예: 삼각형이 (5, 2, 10) 위치로 이동                                    │
//  │                                                                             │
//  │         ┌────────────────────────────────┐                                 │
//  │         │  Y                              │                                 │
//  │         │  │    ▲ (삼각형 at 5,2,10)      │                                 │
//  │         │  │   ╱ ╲                        │                                 │
//  │         │  │  ╱   ╲     ● (다른 오브젝트) │                                 │
//  │         │  └────────────── X              │                                 │
//  │         │ ╱                               │                                 │
//  │         │Z                                │                                 │
//  │         └────────────────────────────────┘                                 │
//  │                    │                                                        │
//  │                    │ × View Matrix (카메라 위치/방향)                        │
//  │                    ▼                                                        │
//  │  3. 뷰 공간 (View/Eye/Camera Space)                                         │
//  │     ───────────────────────────────                                         │
//  │     • 카메라 기준 좌표계                                                     │
//  │     • 카메라가 원점에 위치                                                   │
//  │     • 카메라가 +Z 방향을 바라봄 (왼손 좌표계)                                 │
//  │                                                                             │
//  │         ┌────────────────────────────────┐                                 │
//  │         │           ▲ (삼각형)            │                                 │
//  │         │          ╱ ╲                    │                                 │
//  │         │         ╱   ╲                   │                                 │
//  │         │  카메라 ●────────────▶ +Z       │                                 │
//  │         │       (0,0,0)                   │                                 │
//  │         └────────────────────────────────┘                                 │
//  │                    │                                                        │
//  │                    │ × Projection Matrix (원근 투영)                        │
//  │                    ▼                                                        │
//  │  4. 클립 공간 (Clip Space)                                                  │
//  │     ─────────────────────                                                   │
//  │     • 동차 좌표 (x, y, z, w)                                                │
//  │     • -w ≤ x ≤ w, -w ≤ y ≤ w, 0 ≤ z ≤ w (Metal)                           │
//  │     • 이 범위 밖의 지오메트리는 클리핑됨                                      │
//  │                                                                             │
//  │                    │                                                        │
//  │                    │ ÷ w (원근 분할, Perspective Division)                  │
//  │                    ▼                                                        │
//  │  5. NDC 공간 (Normalized Device Coordinates)                                │
//  │     ─────────────────────────────────────                                   │
//  │     • -1 ≤ x ≤ 1                                                           │
//  │     • -1 ≤ y ≤ 1                                                           │
//  │     • 0 ≤ z ≤ 1 (Metal의 깊이 범위)                                         │
//  │                                                                             │
//  │         ┌────────────────────┐                                             │
//  │         │    (-1,1)  (1,1)   │                                             │
//  │         │      ┌──────┐      │                                             │
//  │         │      │      │      │                                             │
//  │         │      │      │      │                                             │
//  │         │      └──────┘      │                                             │
//  │         │   (-1,-1) (1,-1)   │                                             │
//  │         └────────────────────┘                                             │
//  │                    │                                                        │
//  │                    │ × Viewport Transform (뷰포트 변환)                     │
//  │                    ▼                                                        │
//  │  6. 스크린 공간 (Screen Space)                                              │
//  │     ─────────────────────────                                               │
//  │     • 실제 픽셀 좌표                                                         │
//  │     • 0 ≤ x ≤ width                                                        │
//  │     • 0 ≤ y ≤ height                                                       │
//  │                                                                             │
//  │         ┌────────────────────┐                                             │
//  │         │ (0,0)              │                                             │
//  │         │   ●────────────▶   │                                             │
//  │         │   │                │                                             │
//  │         │   │    ▲           │                                             │
//  │         │   │   ╱ ╲          │                                             │
//  │         │   │  ╱   ╲         │                                             │
//  │         │   ▼ ▼─────▼        │                                             │
//  │         │         (width,height)                                           │
//  │         └────────────────────┘                                             │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제4장: Metal 기본 객체 모델
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal의 핵심 객체들과 그 관계를 이해하는 것이 중요합니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                          Metal 객체 계층 구조                                │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   ┌──────────────────────────────────────────────────────────────────┐     │
//  │   │                         MTLDevice                                 │     │
//  │   │                   (GPU를 나타내는 최상위 객체)                      │     │
//  │   │                                                                   │     │
//  │   │  • MTLCreateSystemDefaultDevice()로 획득                          │     │
//  │   │  • 다른 모든 Metal 객체 생성의 시작점                              │     │
//  │   │  • 디바이스 특성 쿼리 (기능 지원 여부 등)                          │     │
//  │   └─────────────────────────────┬────────────────────────────────────┘     │
//  │                                 │                                          │
//  │         ┌───────────────────────┼───────────────────────┐                  │
//  │         │                       │                       │                  │
//  │         ▼                       ▼                       ▼                  │
//  │   ┌───────────┐           ┌───────────┐           ┌───────────┐           │
//  │   │MTLCommand │           │ MTLBuffer │           │MTLTexture │           │
//  │   │  Queue    │           │           │           │           │           │
//  │   └─────┬─────┘           └───────────┘           └───────────┘           │
//  │         │                       │                       │                  │
//  │         │              ┌────────┴────────┐              │                  │
//  │         │              │                 │              │                  │
//  │         │        .storageModeShared .storageModePrivate │                  │
//  │         │        (CPU+GPU 공유)    (GPU 전용)           │                  │
//  │         │                                                                  │
//  │         ▼                                                                  │
//  │   ┌───────────┐                                                           │
//  │   │MTLCommand │   매 프레임마다 생성 (기존 Metal)                          │
//  │   │  Buffer   │   또는 재사용 (Metal 4)                                   │
//  │   └─────┬─────┘                                                           │
//  │         │                                                                  │
//  │         ├─────────────────────┬─────────────────────┐                     │
//  │         │                     │                     │                     │
//  │         ▼                     ▼                     ▼                     │
//  │   ┌───────────┐         ┌───────────┐         ┌───────────┐              │
//  │   │  Render   │         │  Compute  │         │   Blit    │              │
//  │   │ Command   │         │ Command   │         │ Command   │              │
//  │   │ Encoder   │         │ Encoder   │         │ Encoder   │              │
//  │   └───────────┘         └───────────┘         └───────────┘              │
//  │   그래픽 렌더링          컴퓨트 셰이더        메모리 복사                  │
//  │                                                                           │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  주요 객체 설명:
//  ─────────────────────────────────────────────────────────────────────────────
//
//  MTLDevice
//  ─────────
//  GPU를 추상화한 최상위 객체입니다. 애플리케이션에서 단 하나만 필요합니다.
//  모든 Metal 리소스(버퍼, 텍스처, 파이프라인 등)를 생성합니다.
//
//  MTLCommandQueue
//  ───────────────
//  Command Buffer들을 GPU에 제출하는 대기열입니다.
//  일반적으로 애플리케이션당 하나만 생성합니다.
//  스레드 안전하므로 여러 스레드에서 사용 가능합니다.
//
//  MTLCommandBuffer
//  ────────────────
//  GPU가 실행할 명령들의 컨테이너입니다.
//  인코더를 통해 명령을 기록한 후 commit()으로 제출합니다.
//  기존 Metal: 매 프레임 새로 생성
//  Metal 4: 재사용 + CommandAllocator
//
//  MTLRenderCommandEncoder
//  ───────────────────────
//  렌더링 명령을 Command Buffer에 기록합니다.
//  파이프라인 설정, 버퍼 바인딩, 드로우 콜 등을 인코딩합니다.
//
//  MTLBuffer
//  ─────────
//  GPU 메모리에 데이터를 저장하는 컨테이너입니다.
//  버텍스 데이터, 유니폼 데이터, 인덱스 데이터 등을 저장합니다.
//
//  MTLRenderPipelineState
//  ──────────────────────
//  렌더링 파이프라인의 컴파일된 상태입니다.
//  버텍스/프래그먼트 셰이더, 픽셀 포맷 등을 포함합니다.
//  생성 비용이 비싸므로 초기화 시 한 번만 생성합니다.
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제5장: Metal 4의 혁신적 변화
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal 4는 WWDC 2025에서 발표된 메이저 업데이트로,
//  기존 Metal API를 현대화하고 더 효율적인 GPU 활용을 가능하게 합니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                        Metal 4 아키텍처 개요                                  │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   ┌─────────────┐    ┌─────────────────┐    ┌──────────────────┐           │
//  │   │   MTLDevice │───▶│ MTL4CommandQueue│───▶│ MTL4CommandBuffer│           │
//  │   └─────────────┘    └─────────────────┘    └──────────────────┘           │
//  │          │                                           │                      │
//  │          ▼                                           ▼                      │
//  │   ┌─────────────┐                          ┌──────────────────┐            │
//  │   │MTL4Compiler │                          │RenderCommandEncoder           │
//  │   └─────────────┘                          └──────────────────┘            │
//  │          │                                           │                      │
//  │          ▼                                           ▼                      │
//  │   ┌─────────────┐    ┌─────────────────┐    ┌──────────────────┐           │
//  │   │PipelineState│    │  ResidencySet   │    │  ArgumentTable   │           │
//  │   └─────────────┘    └─────────────────┘    └──────────────────┘           │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  Metal 4 vs 기존 Metal 상세 비교:
//  ═════════════════════════════════════════════════════════════════════════════
//
//  ┌──────────────────────┬──────────────────────┬────────────────────────────┐
//  │        기능          │      기존 Metal       │         Metal 4            │
//  ├──────────────────────┼──────────────────────┼────────────────────────────┤
//  │ Command Queue        │ MTLCommandQueue      │ MTL4CommandQueue           │
//  │ Command Buffer       │ 매 프레임 새로 생성    │ 재사용 + CommandAllocator  │
//  │ Resource Binding     │ setVertexBuffer()    │ ArgumentTable + GPU Address│
//  │ Pipeline Creation    │ MTLDevice            │ MTL4Compiler               │
//  │ Memory Management    │ 암시적               │ ResidencySet (명시적)       │
//  │ Synchronization      │ waitUntilCompleted   │ SharedEvent + Signal       │
//  │ Drawable Handling    │ present() + commit() │ waitForDrawable/signal     │
//  └──────────────────────┴──────────────────────┴────────────────────────────┘
//
//
//  5.1 MTL4CommandQueue & MTL4CommandBuffer
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  기존 Metal에서는 매 프레임마다 새로운 Command Buffer를 생성했습니다.
//  Metal 4에서는 Command Buffer를 재사용하고, CommandAllocator로 메모리를 관리합니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                   Command Buffer 생명주기 비교                               │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   기존 Metal:                                                               │
//  │   ───────────                                                               │
//  │                                                                             │
//  │   Frame 0:  [Create] ──▶ [Encode] ──▶ [Commit] ──▶ [완료] ──▶ [해제]       │
//  │   Frame 1:  [Create] ──▶ [Encode] ──▶ [Commit] ──▶ [완료] ──▶ [해제]       │
//  │   Frame 2:  [Create] ──▶ [Encode] ──▶ [Commit] ──▶ [완료] ──▶ [해제]       │
//  │                                                                             │
//  │   • 매 프레임 commandQueue.makeCommandBuffer() 호출                         │
//  │   • 메모리 할당/해제 오버헤드 발생                                           │
//  │                                                                             │
//  │                                                                             │
//  │   Metal 4:                                                                  │
//  │   ─────────                                                                 │
//  │                                                                             │
//  │   CommandBuffer (재사용) ─────────────────────────────────────▶             │
//  │        │                                                                    │
//  │        ▼                                                                    │
//  │   ┌─────────┐                                                              │
//  │   │Allocator│ ← Frame 0 데이터                                             │
//  │   │   [0]   │                                                              │
//  │   └─────────┘                                                              │
//  │   ┌─────────┐                                                              │
//  │   │Allocator│ ← Frame 1 데이터                                             │
//  │   │   [1]   │                                                              │
//  │   └─────────┘                                                              │
//  │   ┌─────────┐                                                              │
//  │   │Allocator│ ← Frame 2 데이터                                             │
//  │   │   [2]   │                                                              │
//  │   └─────────┘                                                              │
//  │        │                                                                    │
//  │        └── Frame 3: Allocator[0].reset() 후 재사용                         │
//  │                                                                             │
//  │   • CommandBuffer 객체는 재사용                                             │
//  │   • 커맨드 데이터는 Allocator에 저장                                        │
//  │   • Triple Buffering으로 3개의 Allocator 순환                               │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  코드 비교:
//  ──────────
//
//  // 기존 Metal
//  func draw(in view: MTKView) {
//      let commandBuffer = commandQueue.makeCommandBuffer()!  // 매 프레임 생성
//      // ... 인코딩 ...
//      commandBuffer.present(drawable)
//      commandBuffer.commit()
//  }
//
//  // Metal 4
//  func draw(in view: MTKView) {
//      allocator.reset()  // 이전 데이터 해제
//      commandBuffer.beginCommandBuffer(allocator: allocator)  // 시작
//      // ... 인코딩 ...
//      commandBuffer.endCommandBuffer()  // 종료
//      commandQueue.commit([commandBuffer])  // 제출
//  }
//
//
//  5.2 MTL4ArgumentTable (리소스 바인딩)
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal 4는 GPU 주소를 직접 사용하는 새로운 리소스 바인딩 방식을 도입했습니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                     리소스 바인딩 방식 비교                                   │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   기존 Metal:                                                               │
//  │   ───────────                                                               │
//  │                                                                             │
//  │   ┌───────────────────┐                     ┌───────────────┐              │
//  │   │  RenderEncoder    │                     │   Shader      │              │
//  │   │                   │                     │               │              │
//  │   │  setVertexBuffer  │ ──── index 0 ────▶ │ [[buffer(0)]] │              │
//  │   │  (buffer, 0, 0)   │                     │               │              │
//  │   │                   │                     │               │              │
//  │   │  setVertexBuffer  │ ──── index 1 ────▶ │ [[buffer(1)]] │              │
//  │   │  (buffer, 0, 1)   │                     │               │              │
//  │   └───────────────────┘                     └───────────────┘              │
//  │                                                                             │
//  │   • 인코더에서 직접 버퍼 바인딩                                              │
//  │   • 인덱스 기반 바인딩                                                       │
//  │                                                                             │
//  │                                                                             │
//  │   Metal 4:                                                                  │
//  │   ─────────                                                                 │
//  │                                                                             │
//  │   ┌───────────────────┐     ┌───────────────┐     ┌───────────────┐       │
//  │   │  ArgumentTable    │     │ RenderEncoder │     │   Shader      │       │
//  │   │                   │     │               │     │               │       │
//  │   │  setAddress       │     │setArgumentTable────▶│ [[buffer(0)]] │       │
//  │   │  (gpuAddr, 0)     │─────│ (table, .vertex)    │               │       │
//  │   │                   │     │               │     │               │       │
//  │   │  setAddress       │     │               │     │ [[buffer(1)]] │       │
//  │   │  (gpuAddr, 1)     │     │               │     │               │       │
//  │   └───────────────────┘     └───────────────┘     └───────────────┘       │
//  │                                                                             │
//  │   • GPU 주소를 Argument Table에 설정                                        │
//  │   • 테이블을 인코더에 한 번에 바인딩                                         │
//  │   • 더 유연하고 효율적인 바인딩                                              │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  GPU Address란?
//  ──────────────
//  Metal 4에서 모든 버퍼는 64비트 GPU 가상 주소를 가집니다.
//  buffer.gpuAddress로 접근할 수 있으며, 이 주소를 셰이더에 직접 전달할 수 있습니다.
//
//  let vertexAddr = vertexBuffer.gpuAddress   // UInt64
//  let uniformAddr = uniformBuffer.gpuAddress // UInt64
//
//  argumentTable.setAddress(vertexAddr, index: 0)
//  argumentTable.setAddress(uniformAddr, index: 1)
//
//
//  5.3 MTLResidencySet (메모리 관리)
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal 4는 GPU 메모리 레지던시를 명시적으로 관리합니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                        ResidencySet 개념                                    │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   ResidencySet은 "이 리소스들이 GPU에서 사용될 것이다"라고 명시적으로         │
//  │   GPU에 알려주는 역할을 합니다.                                              │
//  │                                                                             │
//  │   ┌───────────────────────────────────────────────────────────────┐        │
//  │   │                      ResidencySet                             │        │
//  │   │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐             │        │
//  │   │  │VertexBuffer │ │UniformBuffer│ │   Texture   │  ...        │        │
//  │   │  └─────────────┘ └─────────────┘ └─────────────┘             │        │
//  │   └───────────────────────────────────────────────────────────────┘        │
//  │                              │                                              │
//  │                              │ commit()                                     │
//  │                              ▼                                              │
//  │   ┌───────────────────────────────────────────────────────────────┐        │
//  │   │                    MTL4CommandQueue                           │        │
//  │   │                                                               │        │
//  │   │   addResidencySet(residencySet)                               │        │
//  │   │   ─────────────────────────────                               │        │
//  │   │   "이 큐의 커맨드들은 이 리소스들을 사용할 것이다"               │        │
//  │   │                                                               │        │
//  │   └───────────────────────────────────────────────────────────────┘        │
//  │                                                                             │
//  │   장점:                                                                     │
//  │   • GPU가 필요한 리소스만 메모리에 상주시킴                                  │
//  │   • 메모리 사용량 최적화                                                    │
//  │   • 리소스 수명 명확화                                                      │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  사용 패턴:
//  ──────────
//
//  // 1. ResidencySet 생성
//  let descriptor = MTLResidencySetDescriptor()
//  descriptor.initialCapacity = 16
//  let residencySet = device.makeResidencySet(descriptor: descriptor)
//
//  // 2. 리소스 등록
//  residencySet.addAllocation(vertexBuffer)
//  residencySet.addAllocation(uniformBuffer)
//  residencySet.addAllocation(texture)
//
//  // 3. 커밋 (변경사항 적용)
//  residencySet.commit()
//
//  // 4. CommandQueue에 연결
//  commandQueue.addResidencySet(residencySet)
//
//
//  5.4 MTL4Compiler (파이프라인 컴파일)
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal 4는 파이프라인 상태 생성을 위한 전용 컴파일러 객체를 도입했습니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                     파이프라인 생성 방식 비교                                 │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   기존 Metal:                                                               │
//  │   ───────────                                                               │
//  │                                                                             │
//  │   MTLDevice ──▶ makeRenderPipelineState(descriptor:)                       │
//  │                                                                             │
//  │   let pipelineState = try device.makeRenderPipelineState(                  │
//  │       descriptor: pipelineDescriptor                                        │
//  │   )                                                                         │
//  │                                                                             │
//  │                                                                             │
//  │   Metal 4:                                                                  │
//  │   ─────────                                                                 │
//  │                                                                             │
//  │   MTLDevice ──▶ MTL4Compiler ──▶ makeRenderPipelineState(descriptor:)      │
//  │                                                                             │
//  │   // 1. 컴파일러 생성                                                       │
//  │   let compilerDescriptor = MTL4CompilerDescriptor()                         │
//  │   let compiler = try device.makeCompiler(descriptor: compilerDescriptor)    │
//  │                                                                             │
//  │   // 2. 함수 디스크립터 생성                                                 │
//  │   let vertexFuncDesc = MTL4LibraryFunctionDescriptor()                      │
//  │   vertexFuncDesc.name = "vertexShader"                                      │
//  │   vertexFuncDesc.library = library                                          │
//  │                                                                             │
//  │   // 3. 파이프라인 디스크립터 설정                                           │
//  │   let pipelineDesc = MTL4RenderPipelineDescriptor()                         │
//  │   pipelineDesc.vertexFunctionDescriptor = vertexFuncDesc                    │
//  │   pipelineDesc.fragmentFunctionDescriptor = fragmentFuncDesc                │
//  │                                                                             │
//  │   // 4. 컴파일                                                              │
//  │   let pipelineState = try compiler.makeRenderPipelineState(                 │
//  │       descriptor: pipelineDesc                                              │
//  │   )                                                                         │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//
//  5.5 동기화 메커니즘 (MTLSharedEvent)
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal 4는 SharedEvent를 통해 CPU-GPU 간 세밀한 동기화를 제공합니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                     동기화 메커니즘 상세                                      │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   SharedEvent는 카운터 기반의 동기화 프리미티브입니다.                        │
//  │   GPU가 특정 작업을 완료하면 이벤트 값을 시그널하고,                          │
//  │   CPU나 다른 커맨드 버퍼가 그 값을 기다릴 수 있습니다.                        │
//  │                                                                             │
//  │   ┌─────────────────────────────────────────────────────────────────┐      │
//  │   │                                                                 │      │
//  │   │   CPU Timeline:                                                 │      │
//  │   │   ─────────────                                                 │      │
//  │   │                                                                 │      │
//  │   │   Frame 0        Frame 1        Frame 2        Frame 3          │      │
//  │   │   ═══════════════════════════════════════════════════════════▶  │      │
//  │   │      │              │              │              │             │      │
//  │   │      │ encode       │ encode       │ encode       │ encode      │      │
//  │   │      │              │              │              │             │      │
//  │   │      ▼              ▼              ▼              ▼             │      │
//  │   │   submit         submit         submit         submit           │      │
//  │   │      │              │              │              │             │      │
//  │   │      │              │              │ ◀─── wait(0) │             │      │
//  │   │      │              │              │     (Frame0 완료 대기)      │      │
//  │   │                                                                 │      │
//  │   │   GPU Timeline:                                                 │      │
//  │   │   ─────────────                                                 │      │
//  │   │                                                                 │      │
//  │   │   ═══════════════════════════════════════════════════════════▶  │      │
//  │   │      ┌────────┐     ┌────────┐     ┌────────┐                   │      │
//  │   │      │Frame 0 │     │Frame 1 │     │Frame 2 │                   │      │
//  │   │      │render  │     │render  │     │render  │                   │      │
//  │   │      └───┬────┘     └───┬────┘     └───┬────┘                   │      │
//  │   │          │              │              │                         │      │
//  │   │          ▼              ▼              ▼                         │      │
//  │   │      signal(0)      signal(1)      signal(2)                    │      │
//  │   │                                                                 │      │
//  │   │                                                                 │      │
//  │   │   SharedEvent Value:  0 ──▶ 1 ──▶ 2 ──▶ 3 ...                  │      │
//  │   │                                                                 │      │
//  │   └─────────────────────────────────────────────────────────────────┘      │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  Triple Buffering 동기화:
//  ────────────────────────
//
//  // 프레임 N을 렌더링하려면 프레임 N-3이 완료되어야 함
//  if frameIndex >= maxFramesInFlight {
//      let waitValue = frameIndex - maxFramesInFlight
//      frameCompletionEvent.wait(untilSignaledValue: waitValue, timeoutMS: 8)
//  }
//
//  // ... 렌더링 ...
//
//  // 프레임 완료 시그널
//  commandQueue.signalEvent(frameCompletionEvent, value: frameIndex)
//
//
//  5.6 Drawable 처리 방식
//  ━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal 4는 Drawable 처리 방식도 변경되었습니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                     Drawable 처리 비교                                       │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   기존 Metal:                                                               │
//  │   ───────────                                                               │
//  │                                                                             │
//  │   commandBuffer.present(drawable)  // Drawable 표시 예약                    │
//  │   commandBuffer.commit()           // GPU에 제출                            │
//  │                                                                             │
//  │                                                                             │
//  │   Metal 4:                                                                  │
//  │   ─────────                                                                 │
//  │                                                                             │
//  │   // 1. Drawable 준비 대기                                                  │
//  │   commandQueue.waitForDrawable(drawable)                                   │
//  │                                                                             │
//  │   // 2. 커맨드 버퍼 제출                                                    │
//  │   commandQueue.commit([commandBuffer])                                     │
//  │                                                                             │
//  │   // 3. Drawable 완료 시그널                                                │
//  │   commandQueue.signalDrawable(drawable)                                    │
//  │                                                                             │
//  │   // 4. 화면에 표시                                                         │
//  │   drawable.present()                                                        │
//  │                                                                             │
//  │   장점:                                                                     │
//  │   • 더 세밀한 Drawable 수명 제어                                            │
//  │   • 명시적인 동기화 지점                                                    │
//  │   • 디스플레이 동기화 최적화                                                │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제6장: 성능 최적화 기법
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  6.1 Triple Buffering
//  ━━━━━━━━━━━━━━━━━━━━━
//
//  CPU와 GPU가 병렬로 작업할 수 있도록 여러 프레임 버퍼를 사용합니다.
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                      Triple Buffering 동작                                   │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   시간 ────────────────────────────────────────────────────────────────▶    │
//  │                                                                             │
//  │   CPU:   [Encode 0] [Encode 1] [Encode 2] [Wait 0] [Encode 3] [Wait 1]     │
//  │                                              │                              │
//  │   GPU:        [Render 0] [Render 1] [Render 2] [Render 3]                  │
//  │                    │                    │                                   │
//  │                    ▼                    ▼                                   │
//  │               Signal 0             Signal 2                                 │
//  │                                                                             │
//  │   • CPU는 GPU가 N-3 프레임 완료할 때까지만 대기                              │
//  │   • 나머지 시간은 CPU와 GPU가 병렬로 작업                                    │
//  │   • 최대 3개의 프레임이 동시에 처리됨                                        │
//  │                                                                             │
//  │   버퍼 사용:                                                                │
//  │   ──────────                                                                │
//  │   Frame 0: uniformBuffers[0]                                               │
//  │   Frame 1: uniformBuffers[1]                                               │
//  │   Frame 2: uniformBuffers[2]                                               │
//  │   Frame 3: uniformBuffers[0]  ← Frame 0 완료 후 재사용                      │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//  6.2 버퍼 관리 Best Practices
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  ┌─────────────────────────────────────────────────────────────────────────────┐
//  │                       버퍼 스토리지 모드                                      │
//  ├─────────────────────────────────────────────────────────────────────────────┤
//  │                                                                             │
//  │   .storageModeShared (공유 모드)                                            │
//  │   ────────────────────────────                                              │
//  │   • CPU와 GPU 모두 접근 가능                                                │
//  │   • Apple Silicon에서 복사 없이 즉시 접근                                   │
//  │   • 작은 버퍼, 자주 업데이트되는 버퍼에 적합                                 │
//  │   • 예: 유니폼 버퍼                                                         │
//  │                                                                             │
//  │   .storageModePrivate (GPU 전용 모드)                                       │
//  │   ──────────────────────────────                                            │
//  │   • GPU만 접근 가능                                                         │
//  │   • GPU 메모리에서 최적화된 레이아웃                                         │
//  │   • 큰 버퍼, 변경되지 않는 버퍼에 적합                                       │
//  │   • 예: 정적 메시 데이터, 텍스처                                            │
//  │   • CPU에서 데이터 설정 시 Blit으로 복사 필요                                │
//  │                                                                             │
//  │   .storageModeManaged (관리 모드, macOS만)                                  │
//  │   ──────────────────────────────────────                                    │
//  │   • CPU 복사본과 GPU 복사본 분리 관리                                       │
//  │   • didModifyRange()로 동기화                                               │
//  │   • Intel Mac에서 사용                                                      │
//  │                                                                             │
//  └─────────────────────────────────────────────────────────────────────────────┘
//
//
//  파일 구조:
//  ─────────────────────────────────────────────────────────────────────────
//  1. 데이터 구조체 (Vertex, Uniforms)
//  2. Metal4Renderer - Metal 4 API 기반 렌더러 (macOS 26.0+, iOS 26.0+)
//  3. LegacyMetalRenderer - 기존 Metal API 기반 렌더러 (하위 호환성)
//

import MetalKit
import simd

// ════════════════════════════════════════════════════════════════════════════
// MARK: - 데이터 구조체 (Data Structures)
// ════════════════════════════════════════════════════════════════════════════

/// 버텍스(정점) 데이터 구조체
///
/// 3D 공간의 각 정점에 대한 위치와 색상 정보를 저장합니다.
/// GPU의 Metal 셰이더(`Shaders.metal`)와 메모리 레이아웃이 일치해야 합니다.
///
/// ## 메모리 레이아웃
///
/// ```
/// ┌─────────────────────────────────────────────────────────────┐
/// │ Offset 0-11    │ Offset 12-15  │ Offset 16-31              │
/// │ position       │ (padding)     │ color                     │
/// │ SIMD3<Float>   │               │ SIMD4<Float>              │
/// │ x, y, z        │               │ r, g, b, a                │
/// └─────────────────────────────────────────────────────────────┘
/// Total stride: 32 bytes (SIMD3는 16바이트로 정렬됨)
/// ```
///
/// ## 삼각형 정의 예시
///
/// ```
///            (0.0, 0.5, 0.0) 빨강
///                  ▲
///                 ╱ ╲
///                ╱   ╲
///               ╱     ╲
///              ╱       ╲
///             ╱         ╲
///            ▼───────────▼
/// (-0.5, -0.5, 0.0)   (0.5, -0.5, 0.0)
///       파랑                초록
/// ```
///
/// - Note: SIMD3<Float>는 12바이트지만 Metal은 16바이트 정렬을 사용할 수 있습니다.
///         `MemoryLayout<Vertex>.stride`를 사용하여 실제 크기를 확인하세요.
struct Vertex {
    /// 3D 공간에서의 버텍스 위치
    ///
    /// 왼손 좌표계 기준:
    /// - x: 양수 = 오른쪽, 음수 = 왼쪽
    /// - y: 양수 = 위쪽, 음수 = 아래쪽
    /// - z: 양수 = 화면 안쪽(멀어짐), 음수 = 화면 바깥쪽(가까워짐)
    var position: SIMD3<Float>

    /// 버텍스 색상 (RGBA)
    ///
    /// 각 컴포넌트는 0.0 ~ 1.0 범위:
    /// - x (r): 빨간색 강도
    /// - y (g): 초록색 강도
    /// - z (b): 파란색 강도
    /// - w (a): 알파(불투명도), 1.0 = 완전 불투명
    var color: SIMD4<Float>
}

/// 유니폼(Uniform) 데이터 구조체
///
/// 모든 버텍스에 동일하게 적용되는 변환 행렬들을 포함합니다.
/// 매 프레임마다 CPU에서 계산되어 GPU로 전달됩니다.
///
/// ## 변환 순서 (Transformation Pipeline)
///
/// ```
/// ┌──────────┐     Model      ┌──────────┐     View       ┌──────────┐
/// │  Local   │ ─────────────▶ │  World   │ ─────────────▶ │   Eye    │
/// │  Space   │    Matrix      │  Space   │    Matrix      │  Space   │
/// └──────────┘                └──────────┘                └──────────┘
///                                                               │
///                                                               │ Projection
///                                                               │ Matrix
///                                                               ▼
///                                                         ┌──────────┐
///                                                         │   Clip   │
///                                                         │  Space   │
///                                                         └──────────┘
/// ```
///
/// ## 행렬 곱셈 순서
///
/// ```swift
/// clipPosition = projectionMatrix × viewMatrix × modelMatrix × localPosition
/// ```
///
/// - Important: Metal은 column-major 행렬을 사용합니다.
struct Uniforms {
    /// 모델 변환 행렬
    ///
    /// 오브젝트의 로컬 좌표를 월드 좌표로 변환합니다.
    /// 이 프로젝트에서는 Y축 회전에 사용됩니다.
    var modelMatrix: float4x4

    /// 뷰 변환 행렬
    ///
    /// 월드 좌표를 카메라 기준 좌표로 변환합니다.
    /// `lookAtLH()` 함수로 생성됩니다.
    var viewMatrix: float4x4

    /// 투영 변환 행렬
    ///
    /// 3D 좌표를 2D 클립 좌표로 변환합니다.
    /// `perspectiveProjectionLH()` 함수로 생성됩니다.
    var projectionMatrix: float4x4
}


// ════════════════════════════════════════════════════════════════════════════
// MARK: - Metal 4 Renderer
// ════════════════════════════════════════════════════════════════════════════

/// Metal 4 기반 렌더러
///
/// WWDC 2025에서 발표된 Metal 4 API를 사용하여 3D 그래픽을 렌더링합니다.
/// 왼손 좌표계와 원근 투영을 사용하여 회전하는 삼각형을 표시합니다.
///
/// ## Metal 4의 주요 특징
///
/// ### 1. MTL4CommandQueue & MTL4CommandBuffer
/// ```
/// 기존 Metal:
/// ┌─────────────────────────────────────────────────────┐
/// │ 매 프레임마다 새로운 CommandBuffer 생성              │
/// │ commandQueue.makeCommandBuffer() → 사용 → 폐기      │
/// └─────────────────────────────────────────────────────┘
///
/// Metal 4:
/// ┌─────────────────────────────────────────────────────┐
/// │ CommandBuffer 재사용 + CommandAllocator             │
/// │ commandBuffer.beginCommandBuffer(allocator:)        │
/// │ ... 렌더링 명령 ...                                  │
/// │ commandBuffer.endCommandBuffer()                    │
/// └─────────────────────────────────────────────────────┘
/// ```
///
/// ### 2. MTL4ArgumentTable
/// ```
/// 기존 Metal:
///   renderEncoder.setVertexBuffer(buffer, offset: 0, index: 0)
///
/// Metal 4:
///   argumentTable.setAddress(buffer.gpuAddress, index: 0)
///   renderEncoder.setArgumentTable(argumentTable, stages: .vertex)
/// ```
///
/// ### 3. MTLResidencySet
/// ```
/// GPU 메모리 관리를 명시적으로 제어:
///   residencySet.addAllocation(buffer)
///   residencySet.commit()
///   commandQueue.addResidencySet(residencySet)
/// ```
///
/// ### 4. MTL4Compiler
/// ```
/// 파이프라인 상태 생성을 위한 새로운 컴파일러:
///   let compiler = device.makeCompiler(descriptor:)
///   let pipelineState = compiler.makeRenderPipelineState(descriptor:)
/// ```
///
/// ## 프레임 동기화 (Triple Buffering)
///
/// ```
/// Frame 0: [Render] [Wait GPU] [        ]
/// Frame 1: [      ] [Render  ] [Wait GPU]
/// Frame 2: [      ] [        ] [Render  ]
/// Frame 3: [Render] [        ] [        ]  ← Frame 0의 GPU 완료 후 재사용
/// ```
///
/// - Requires: macOS 26.0+, iOS 26.0+, visionOS 26.0+
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
class Metal4Renderer: NSObject, MTKViewDelegate {

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Properties
    // ════════════════════════════════════════════════════════════════════════

    /// Metal 디바이스
    ///
    /// GPU를 추상화한 객체입니다. 모든 Metal 리소스 생성의 시작점입니다.
    /// `MTLCreateSystemDefaultDevice()`로 시스템의 기본 GPU를 가져옵니다.
    let device: MTLDevice

    /// 동시 처리 가능한 최대 프레임 수 (Triple Buffering)
    ///
    /// CPU와 GPU가 병렬로 작업할 수 있도록 3개의 프레임 버퍼를 사용합니다.
    /// - Frame N: GPU에서 렌더링 중
    /// - Frame N+1: CPU에서 준비 중
    /// - Frame N+2: 대기 중
    let maxFramesInFlight: UInt64 = 3

    // ────────────────────────────────────────────────────────────────────────
    // Metal 4 Core Objects
    // ────────────────────────────────────────────────────────────────────────

    /// Metal 4 커맨드 큐
    ///
    /// GPU에 제출할 커맨드 버퍼들의 대기열입니다.
    /// Metal 4에서는 `MTL4CommandQueue`를 사용하여 더 효율적인
    /// 커맨드 제출과 동기화를 지원합니다.
    private let commandQueue: MTL4CommandQueue

    /// Metal 4 커맨드 버퍼 (재사용)
    ///
    /// Metal 4에서는 커맨드 버퍼를 재사용할 수 있습니다.
    /// `beginCommandBuffer(allocator:)` / `endCommandBuffer()`로
    /// 각 프레임의 시작과 끝을 표시합니다.
    private let commandBuffer: MTL4CommandBuffer

    /// 커맨드 할당자 배열 (프레임당 하나)
    ///
    /// 각 프레임의 커맨드 데이터를 저장하는 메모리 풀입니다.
    /// Triple buffering을 위해 3개의 할당자를 순환 사용합니다.
    ///
    /// ```
    /// Frame 0: allocators[0] → 사용 중
    /// Frame 1: allocators[1] → 사용 중
    /// Frame 2: allocators[2] → 사용 중
    /// Frame 3: allocators[0] → Frame 0 완료 후 재사용 (reset)
    /// ```
    private let commandAllocators: [MTL4CommandAllocator]

    /// Metal 4 컴파일러
    ///
    /// 셰이더 함수와 파이프라인 설정을 컴파일하여
    /// GPU에서 실행 가능한 파이프라인 상태를 생성합니다.
    private let compiler: MTL4Compiler

    /// 레지던시 셋 (GPU 메모리 관리)
    ///
    /// GPU가 접근해야 하는 리소스들을 명시적으로 등록합니다.
    /// Metal 4에서는 이 방식으로 메모리 관리를 더 세밀하게 제어할 수 있습니다.
    ///
    /// ```swift
    /// residencySet.addAllocation(vertexBuffer)
    /// residencySet.addAllocation(uniformBuffer)
    /// residencySet.commit()  // 변경사항 적용
    /// commandQueue.addResidencySet(residencySet)  // 커맨드 큐에 연결
    /// ```
    private let residencySet: MTLResidencySet

    /// 프레임 완료 이벤트
    ///
    /// CPU-GPU 간 동기화를 위한 공유 이벤트입니다.
    /// 각 프레임 완료 시 시그널되어 다음 프레임이
    /// 해당 리소스를 안전하게 재사용할 수 있음을 알립니다.
    private let frameCompletionEvent: MTLSharedEvent

    /// 버텍스 인자 테이블
    ///
    /// Metal 4의 새로운 리소스 바인딩 방식입니다.
    /// GPU 주소를 직접 설정하여 셰이더에서 접근할 수 있게 합니다.
    ///
    /// ```swift
    /// // 버퍼의 GPU 주소를 인덱스 0에 바인딩
    /// vertexArgumentTable.setAddress(vertexBuffer.gpuAddress, index: 0)
    ///
    /// // 렌더 인코더에 테이블 설정
    /// renderEncoder.setArgumentTable(vertexArgumentTable, stages: .vertex)
    /// ```
    private let vertexArgumentTable: MTL4ArgumentTable

    // ────────────────────────────────────────────────────────────────────────
    // Pipeline & Buffers
    // ────────────────────────────────────────────────────────────────────────

    /// 렌더 파이프라인 상태
    ///
    /// 버텍스 셰이더, 프래그먼트 셰이더, 픽셀 포맷 등
    /// 렌더링에 필요한 모든 설정이 컴파일된 상태입니다.
    private var pipelineState: MTLRenderPipelineState!

    /// 깊이 스텐실 상태
    ///
    /// 깊이 테스트(Depth Test) 설정입니다.
    /// 가까운 물체가 먼 물체를 가리도록 합니다.
    private var depthStencilState: MTLDepthStencilState!

    /// 버텍스 버퍼
    ///
    /// 삼각형의 3개 버텍스 데이터가 저장된 GPU 버퍼입니다.
    private var vertexBuffer: MTLBuffer!

    /// 유니폼 버퍼 배열 (프레임당 하나)
    ///
    /// 각 프레임의 변환 행렬을 저장합니다.
    /// Triple buffering을 위해 3개를 순환 사용합니다.
    private var uniformBuffers: [MTLBuffer]!

    // ────────────────────────────────────────────────────────────────────────
    // Animation State
    // ────────────────────────────────────────────────────────────────────────

    /// 현재 프레임 인덱스
    ///
    /// 매 프레임마다 1씩 증가합니다.
    /// `frameIndex % maxFramesInFlight`로 현재 사용할 버퍼 인덱스를 계산합니다.
    private var frameIndex: UInt64 = 0

    /// 현재 회전 각도 (라디안)
    ///
    /// 매 프레임마다 증가하여 삼각형이 Y축을 중심으로 회전하게 합니다.
    private var rotation: Float = 0

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Initialization
    // ════════════════════════════════════════════════════════════════════════

    /// 렌더러 초기화
    ///
    /// Metal 디바이스, 커맨드 큐, 파이프라인 등 모든 렌더링 리소스를 생성합니다.
    ///
    /// ## 초기화 순서
    ///
    /// ```
    /// 1. MTLDevice 획득
    /// 2. MTL4CommandQueue 생성
    /// 3. MTL4CommandBuffer 생성
    /// 4. MTL4CommandAllocator 배열 생성 (Triple Buffering)
    /// 5. MTL4Compiler 생성
    /// 6. MTLResidencySet 생성
    /// 7. MTLSharedEvent 생성 (동기화용)
    /// 8. MTL4ArgumentTable 생성
    /// 9. MTKView 설정
    /// 10. 버텍스/유니폼 버퍼 생성
    /// 11. 파이프라인 상태 컴파일
    /// 12. 레지던시 셋 설정
    /// ```
    ///
    /// - Parameter mtkView: 렌더링 결과를 표시할 MetalKit 뷰
    /// - Returns: 초기화된 렌더러, 실패 시 nil
    init?(mtkView: MTKView) {
        // ────────────────────────────────────────────────────────────────────
        // 1. Metal Device 획득
        // ────────────────────────────────────────────────────────────────────
        guard let device = MTLCreateSystemDefaultDevice() else {
            print("❌ Metal을 지원하지 않는 디바이스입니다.")
            return nil
        }
        self.device = device

        // ────────────────────────────────────────────────────────────────────
        // 2. Metal 4 Command Queue 생성
        // ────────────────────────────────────────────────────────────────────
        // MTL4CommandQueue는 기존 MTLCommandQueue와 달리
        // 더 세밀한 동기화 제어와 효율적인 커맨드 제출을 지원합니다.
        guard let commandQueue = device.makeMTL4CommandQueue() else {
            print("❌ MTL4CommandQueue 생성 실패")
            return nil
        }
        self.commandQueue = commandQueue

        // ────────────────────────────────────────────────────────────────────
        // 3. Metal 4 Command Buffer 생성
        // ────────────────────────────────────────────────────────────────────
        // Metal 4에서는 커맨드 버퍼를 재사용할 수 있습니다.
        // beginCommandBuffer/endCommandBuffer로 각 프레임을 구분합니다.
        guard let commandBuffer = device.makeCommandBuffer() else {
            print("❌ MTL4CommandBuffer 생성 실패")
            return nil
        }
        self.commandBuffer = commandBuffer

        // ────────────────────────────────────────────────────────────────────
        // 4. Command Allocator 배열 생성 (Triple Buffering)
        // ────────────────────────────────────────────────────────────────────
        // 각 프레임의 커맨드 데이터를 저장할 메모리 풀입니다.
        // 프레임 N이 완료되면 해당 할당자를 reset하여 재사용합니다.
        self.commandAllocators = (0..<maxFramesInFlight).compactMap { _ in
            device.makeCommandAllocator()
        }
        guard commandAllocators.count == Int(maxFramesInFlight) else {
            print("❌ CommandAllocator 생성 실패")
            return nil
        }

        // ────────────────────────────────────────────────────────────────────
        // 5. Metal 4 Compiler 생성
        // ────────────────────────────────────────────────────────────────────
        // 셰이더 함수를 파이프라인 상태로 컴파일합니다.
        let compilerDescriptor = MTL4CompilerDescriptor()
        guard let compiler = try? device.makeCompiler(descriptor: compilerDescriptor) else {
            print("❌ MTL4Compiler 생성 실패")
            return nil
        }
        self.compiler = compiler

        // ────────────────────────────────────────────────────────────────────
        // 6. Residency Set 생성
        // ────────────────────────────────────────────────────────────────────
        // GPU가 접근할 리소스들을 명시적으로 등록합니다.
        let residencyDescriptor = MTLResidencySetDescriptor()
        residencyDescriptor.initialCapacity = 16  // 예상 리소스 수
        guard let residencySet = try? device.makeResidencySet(descriptor: residencyDescriptor) else {
            print("❌ ResidencySet 생성 실패")
            return nil
        }
        self.residencySet = residencySet

        // ────────────────────────────────────────────────────────────────────
        // 7. Frame Completion Event 생성
        // ────────────────────────────────────────────────────────────────────
        // CPU-GPU 간 동기화를 위한 공유 이벤트입니다.
        guard let event = device.makeSharedEvent() else {
            print("❌ SharedEvent 생성 실패")
            return nil
        }
        self.frameCompletionEvent = event

        // ────────────────────────────────────────────────────────────────────
        // 8. Argument Table 생성
        // ────────────────────────────────────────────────────────────────────
        // Metal 4의 새로운 리소스 바인딩 방식입니다.
        let argumentDescriptor = MTL4ArgumentTableDescriptor()
        argumentDescriptor.maxBufferBindCount = 2  // vertices(0) + uniforms(1)
        guard let vertexArgumentTable = try? device.makeArgumentTable(descriptor: argumentDescriptor) else {
            print("❌ ArgumentTable 생성 실패")
            return nil
        }
        self.vertexArgumentTable = vertexArgumentTable

        super.init()

        // ────────────────────────────────────────────────────────────────────
        // 9. MTKView 설정
        // ────────────────────────────────────────────────────────────────────
        mtkView.device = device
        mtkView.clearColor = MTLClearColor(red: 0.1, green: 0.1, blue: 0.1, alpha: 1.0)
        mtkView.colorPixelFormat = .bgra8Unorm_srgb  // sRGB 색공간
        mtkView.depthStencilPixelFormat = .depth32Float  // 32비트 깊이 버퍼

        // 이벤트 초기값 설정
        frameCompletionEvent.signaledValue = frameIndex

        // ────────────────────────────────────────────────────────────────────
        // 10-12. 리소스 생성 및 설정
        // ────────────────────────────────────────────────────────────────────
        buildResources()
        buildPipelineState()
        setupResidency()
    }

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Resource Building
    // ════════════════════════════════════════════════════════════════════════

    /// GPU 리소스 생성
    ///
    /// 버텍스 버퍼, 유니폼 버퍼, 깊이 스텐실 상태를 생성합니다.
    ///
    /// ## 버텍스 데이터
    ///
    /// ```
    ///            Red (0.0, 0.5, 0.0)
    ///                  ▲
    ///                 ╱ ╲
    ///                ╱   ╲
    ///               ╱     ╲
    ///              ╱       ╲
    ///             ╱         ╲
    ///            ▼───────────▼
    ///   Blue (-0.5, -0.5)   Green (0.5, -0.5)
    /// ```
    private func buildResources() {
        // ────────────────────────────────────────────────────────────────────
        // 삼각형 버텍스 정의
        // ────────────────────────────────────────────────────────────────────
        // 왼손 좌표계(Left-Hand Coordinate System):
        // - +X: 오른쪽
        // - +Y: 위쪽
        // - +Z: 화면 안쪽 (멀어지는 방향)
        //
        // 버텍스 순서: 시계 방향 (Counter-Clockwise에서 바라볼 때)
        // Front-face culling을 위해 setFrontFacing(.counterClockwise) 설정 필요
        let vertices: [Vertex] = [
            // 상단 - 빨간색
            Vertex(position: SIMD3<Float>(0.0, 0.5, 0.0),
                   color: SIMD4<Float>(1.0, 0.0, 0.0, 1.0)),

            // 우하단 - 초록색
            Vertex(position: SIMD3<Float>(0.5, -0.5, 0.0),
                   color: SIMD4<Float>(0.0, 1.0, 0.0, 1.0)),

            // 좌하단 - 파란색
            Vertex(position: SIMD3<Float>(-0.5, -0.5, 0.0),
                   color: SIMD4<Float>(0.0, 0.0, 1.0, 1.0))
        ]

        // ────────────────────────────────────────────────────────────────────
        // 버텍스 버퍼 생성
        // ────────────────────────────────────────────────────────────────────
        // .storageModeShared: CPU와 GPU 모두 접근 가능
        // 작은 데이터에 적합하며, 매 프레임 업데이트가 필요한 경우에도 사용
        vertexBuffer = device.makeBuffer(
            bytes: vertices,
            length: MemoryLayout<Vertex>.stride * vertices.count,
            options: .storageModeShared
        )

        // ────────────────────────────────────────────────────────────────────
        // 유니폼 버퍼 배열 생성 (Triple Buffering)
        // ────────────────────────────────────────────────────────────────────
        // 각 프레임이 독립적인 버퍼를 사용하여
        // CPU 업데이트와 GPU 읽기가 충돌하지 않도록 합니다.
        uniformBuffers = (0..<maxFramesInFlight).map { _ in
            device.makeBuffer(
                length: MemoryLayout<Uniforms>.stride,
                options: .storageModeShared
            )!
        }

        // ────────────────────────────────────────────────────────────────────
        // 깊이 스텐실 상태 생성
        // ────────────────────────────────────────────────────────────────────
        // 깊이 테스트: 새 픽셀의 깊이가 기존보다 작으면(가까우면) 그리기
        let depthDescriptor = MTLDepthStencilDescriptor()
        depthDescriptor.isDepthWriteEnabled = true      // 깊이 버퍼 쓰기 활성화
        depthDescriptor.depthCompareFunction = .less    // 더 가까운 것만 그리기
        depthStencilState = device.makeDepthStencilState(descriptor: depthDescriptor)
    }

    /// 렌더 파이프라인 상태 생성
    ///
    /// 버텍스 셰이더와 프래그먼트 셰이더를 컴파일하고
    /// 렌더링 설정을 하나의 파이프라인 상태로 결합합니다.
    ///
    /// ## Metal 4 파이프라인 생성 과정
    ///
    /// ```
    /// ┌─────────────────────────────────────────────────────────────────────┐
    /// │                                                                     │
    /// │  MTLLibrary ──▶ MTL4LibraryFunctionDescriptor ──┐                  │
    /// │  (Shaders.metal)           (vertexShader)       │                  │
    /// │                                                 ▼                  │
    /// │                            MTL4RenderPipelineDescriptor            │
    /// │                                                 │                  │
    /// │  MTLLibrary ──▶ MTL4LibraryFunctionDescriptor ──┘                  │
    /// │                         (fragmentShader)                           │
    /// │                                                 │                  │
    /// │                                                 ▼                  │
    /// │                             MTL4Compiler                           │
    /// │                                                 │                  │
    /// │                                                 ▼                  │
    /// │                         MTLRenderPipelineState                     │
    /// │                                                                     │
    /// └─────────────────────────────────────────────────────────────────────┘
    /// ```
    private func buildPipelineState() {
        // ────────────────────────────────────────────────────────────────────
        // 셰이더 라이브러리 로드
        // ────────────────────────────────────────────────────────────────────
        guard let library = device.makeDefaultLibrary() else {
            fatalError("❌ 기본 Metal 라이브러리를 찾을 수 없습니다. Shaders.metal 파일을 확인하세요.")
        }

        // ────────────────────────────────────────────────────────────────────
        // Metal 4 방식의 함수 디스크립터 생성
        // ────────────────────────────────────────────────────────────────────
        // MTL4LibraryFunctionDescriptor: 셰이더 함수를 참조하는 Metal 4 방식
        let vertexFunctionDescriptor = MTL4LibraryFunctionDescriptor()
        vertexFunctionDescriptor.name = "vertexShader"
        vertexFunctionDescriptor.library = library

        let fragmentFunctionDescriptor = MTL4LibraryFunctionDescriptor()
        fragmentFunctionDescriptor.name = "fragmentShader"
        fragmentFunctionDescriptor.library = library

        // ────────────────────────────────────────────────────────────────────
        // 파이프라인 디스크립터 설정
        // ────────────────────────────────────────────────────────────────────
        let pipelineDescriptor = MTL4RenderPipelineDescriptor()
        pipelineDescriptor.vertexFunctionDescriptor = vertexFunctionDescriptor
        pipelineDescriptor.fragmentFunctionDescriptor = fragmentFunctionDescriptor

        // 색상 첨부 설정 (렌더 타겟)
        // .bgra8Unorm_srgb: 8비트 BGRA, sRGB 색공간 (감마 보정 적용)
        pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm_srgb

        // ────────────────────────────────────────────────────────────────────
        // Metal 4 Compiler로 파이프라인 상태 생성
        // ────────────────────────────────────────────────────────────────────
        do {
            pipelineState = try compiler.makeRenderPipelineState(descriptor: pipelineDescriptor)
        } catch {
            fatalError("❌ 파이프라인 상태 생성 실패: \(error)")
        }
    }

    /// 레지던시 셋 설정
    ///
    /// GPU가 접근해야 하는 모든 리소스를 등록합니다.
    /// Metal 4에서는 이 과정이 필수입니다.
    private func setupResidency() {
        // 버텍스 버퍼 등록
        residencySet.addAllocation(vertexBuffer)

        // 모든 유니폼 버퍼 등록
        for buffer in uniformBuffers {
            residencySet.addAllocation(buffer)
        }

        // 변경사항 커밋
        residencySet.commit()

        // 커맨드 큐에 레지던시 셋 연결
        commandQueue.addResidencySet(residencySet)
    }

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Matrix Functions (Left-Hand Coordinate System)
    // ════════════════════════════════════════════════════════════════════════

    /// 왼손 좌표계 원근 투영 행렬 생성
    ///
    /// 3D 뷰 좌표를 2D 클립 좌표로 변환하는 행렬을 생성합니다.
    /// 멀리 있는 물체가 작게 보이는 원근감을 구현합니다.
    ///
    /// ## 원근 투영 원리
    ///
    /// ```
    ///                    Near Plane              Far Plane
    ///                        │                       │
    ///                   ┌────┼────┐             ┌────┼────┐
    ///                   │    │    │             │    │    │
    ///       Eye ════════╪════════════════════════════╪════▶ +Z
    ///       (카메라)     │    │    │             │    │    │
    ///                   └────┼────┘             └────┼────┘
    ///                        │                       │
    ///                   (크게 보임)              (작게 보임)
    ///
    ///       ◀──── FOV (Field of View) ────▶
    /// ```
    ///
    /// ## 왼손 좌표계 특징
    ///
    /// - Z축 양의 방향이 화면 안쪽 (카메라가 바라보는 방향)
    /// - 깊이 값: 0 (near) ~ 1 (far)
    /// - DirectX, Unity 등에서 사용
    ///
    /// ## 행렬 구조
    ///
    /// ```
    /// ┌                                        ┐
    /// │ xScale    0        0              0    │
    /// │   0    yScale      0              0    │
    /// │   0       0    far/(far-near)     1    │  ← w = z (원근 분할용)
    /// │   0       0   -near*far/(far-near) 0   │
    /// └                                        ┘
    ///
    /// 여기서:
    /// - yScale = 1 / tan(fovy / 2)
    /// - xScale = yScale / aspect
    /// ```
    ///
    /// - Parameters:
    ///   - fovy: 수직 시야각 (라디안). 일반적으로 45° ~ 90° (π/4 ~ π/2)
    ///   - aspect: 화면 종횡비 (width / height)
    ///   - nearZ: 근평면 거리 (이보다 가까운 물체는 클리핑)
    ///   - farZ: 원평면 거리 (이보다 먼 물체는 클리핑)
    /// - Returns: 4x4 원근 투영 행렬
    ///
    /// - Important: nearZ는 0보다 커야 합니다. 0에 가까울수록 깊이 정밀도가 떨어집니다.
    func perspectiveProjectionLH(fovYRadians fovy: Float,
                                  aspect: Float,
                                  nearZ: Float,
                                  farZ: Float) -> float4x4 {
        // 수직 스케일: FOV가 클수록 더 많이 보임 (스케일 감소)
        let yScale = 1 / tan(fovy * 0.5)

        // 수평 스케일: 종횡비 보정
        let xScale = yScale / aspect

        // 깊이 범위
        let zRange = farZ - nearZ

        // Column-major 순서로 행렬 생성
        return float4x4(columns: (
            SIMD4<Float>(xScale, 0, 0, 0),                      // 열 0: X 스케일
            SIMD4<Float>(0, yScale, 0, 0),                      // 열 1: Y 스케일
            SIMD4<Float>(0, 0, farZ / zRange, 1),               // 열 2: Z 매핑 + W=Z
            SIMD4<Float>(0, 0, -nearZ * farZ / zRange, 0)       // 열 3: Z 오프셋
        ))
    }

    /// 왼손 좌표계 Look-At 뷰 행렬 생성
    ///
    /// 카메라의 위치와 방향을 기반으로 월드 좌표를 뷰 좌표로 변환하는 행렬을 생성합니다.
    ///
    /// ## Look-At 개념
    ///
    /// ```
    ///                          target (0, 0, 0)
    ///                               ●
    ///                              ╱│
    ///                             ╱ │
    ///                            ╱  │ up
    ///                           ╱   │
    ///                          ╱    │
    ///                         ╱     │
    ///              eye ●─────╱──────┘
    ///           (0, 0, -3)
    ///                    └── 카메라가 target을 바라봄
    /// ```
    ///
    /// ## 좌표축 계산
    ///
    /// ```
    /// 왼손 좌표계에서:
    /// 1. zAxis (forward) = normalize(target - eye)   // 카메라 → 타겟
    /// 2. xAxis (right)   = normalize(cross(up, zAxis))
    /// 3. yAxis (up)      = cross(zAxis, xAxis)
    /// ```
    ///
    /// ## 결과 행렬
    ///
    /// ```
    /// ┌                                                    ┐
    /// │  xAxis.x   yAxis.x   zAxis.x   0                   │
    /// │  xAxis.y   yAxis.y   zAxis.y   0                   │
    /// │  xAxis.z   yAxis.z   zAxis.z   0                   │
    /// │ -dot(x,e) -dot(y,e) -dot(z,e)  1                   │
    /// └                                                    ┘
    /// 여기서 e = eye (카메라 위치)
    /// ```
    ///
    /// - Parameters:
    ///   - eye: 카메라 위치
    ///   - target: 카메라가 바라보는 지점
    ///   - up: 카메라의 위쪽 방향 (보통 (0, 1, 0))
    /// - Returns: 4x4 뷰 변환 행렬
    func lookAtLH(eye: SIMD3<Float>,
                  target: SIMD3<Float>,
                  up: SIMD3<Float>) -> float4x4 {
        // 왼손 좌표계: 카메라는 +Z 방향을 바라봄
        let zAxis = normalize(target - eye)           // 전방 벡터
        let xAxis = normalize(cross(up, zAxis))       // 우측 벡터
        let yAxis = cross(zAxis, xAxis)               // 상향 벡터

        // 뷰 행렬 = 회전 × 이동 (카메라를 원점으로 이동)
        return float4x4(columns: (
            SIMD4<Float>(xAxis.x, yAxis.x, zAxis.x, 0),
            SIMD4<Float>(xAxis.y, yAxis.y, zAxis.y, 0),
            SIMD4<Float>(xAxis.z, yAxis.z, zAxis.z, 0),
            SIMD4<Float>(-dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1)
        ))
    }

    /// Y축 회전 행렬 생성
    ///
    /// 오브젝트를 Y축(수직축)을 중심으로 회전시키는 행렬을 생성합니다.
    ///
    /// ## 회전 방향
    ///
    /// 왼손 좌표계에서 양의 각도는 위에서 볼 때 시계 방향입니다.
    ///
    /// ```
    ///       +Y (위에서 내려다 봄)
    ///         │
    ///         │    θ > 0
    ///         │   ↻ (시계 방향)
    ///         │
    ///    ─────┼─────▶ +X
    ///         │
    ///         │
    ///         ▼
    ///        +Z
    /// ```
    ///
    /// ## 회전 행렬
    ///
    /// ```
    /// ┌                    ┐
    /// │  cos(θ)  0  -sin(θ)  0 │
    /// │    0     1     0     0 │
    /// │  sin(θ)  0   cos(θ)  0 │
    /// │    0     0     0     1 │
    /// └                    ┘
    /// ```
    ///
    /// - Parameter angle: 회전 각도 (라디안)
    /// - Returns: 4x4 Y축 회전 행렬
    func rotationY(_ angle: Float) -> float4x4 {
        let c = cos(angle)
        let s = sin(angle)

        return float4x4(columns: (
            SIMD4<Float>(c, 0, -s, 0),    // 열 0
            SIMD4<Float>(0, 1, 0, 0),     // 열 1 (Y축은 변화 없음)
            SIMD4<Float>(s, 0, c, 0),     // 열 2
            SIMD4<Float>(0, 0, 0, 1)      // 열 3 (이동 없음)
        ))
    }

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - MTKViewDelegate
    // ════════════════════════════════════════════════════════════════════════

    /// 뷰 크기 변경 콜백
    ///
    /// 창 크기가 변경되거나 화면 회전 시 호출됩니다.
    /// 투영 행렬의 종횡비가 draw(in:)에서 매 프레임 계산되므로
    /// 여기서는 별도 처리가 필요 없습니다.
    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
        // 필요시 렌더 타겟 재생성 등의 작업 수행
    }

    /// 프레임 렌더링
    ///
    /// 매 프레임마다 호출되어 3D 씬을 렌더링합니다.
    ///
    /// ## 렌더링 루프 상세
    ///
    /// ```
    /// ┌─────────────────────────────────────────────────────────────────────┐
    /// │                         Frame N 렌더링                               │
    /// ├─────────────────────────────────────────────────────────────────────┤
    /// │                                                                     │
    /// │  1. 이전 프레임 완료 대기 (N - maxFramesInFlight)                    │
    /// │     └─▶ frameCompletionEvent.wait()                                │
    /// │                                                                     │
    /// │  2. 유니폼 데이터 업데이트                                           │
    /// │     ├─▶ Model Matrix (회전)                                         │
    /// │     ├─▶ View Matrix (카메라)                                        │
    /// │     └─▶ Projection Matrix (원근)                                    │
    /// │                                                                     │
    /// │  3. Command Allocator 리셋                                          │
    /// │     └─▶ allocators[frameIndex % 3].reset()                         │
    /// │                                                                     │
    /// │  4. Command Buffer 시작                                             │
    /// │     └─▶ commandBuffer.beginCommandBuffer(allocator:)               │
    /// │                                                                     │
    /// │  5. Render Pass 실행                                                │
    /// │     ├─▶ makeRenderCommandEncoder()                                  │
    /// │     ├─▶ setArgumentTable() - 버퍼 바인딩                            │
    /// │     ├─▶ drawPrimitives() - 삼각형 그리기                            │
    /// │     └─▶ endEncoding()                                               │
    /// │                                                                     │
    /// │  6. Command Buffer 종료 및 제출                                      │
    /// │     ├─▶ commandBuffer.endCommandBuffer()                            │
    /// │     ├─▶ commandQueue.waitForDrawable()                              │
    /// │     ├─▶ commandQueue.commit([commandBuffer])                        │
    /// │     └─▶ commandQueue.signalDrawable()                               │
    /// │                                                                     │
    /// │  7. 프레임 완료 시그널                                               │
    /// │     └─▶ commandQueue.signalEvent(frameCompletionEvent)              │
    /// │                                                                     │
    /// └─────────────────────────────────────────────────────────────────────┘
    /// ```
    func draw(in view: MTKView) {
        // ────────────────────────────────────────────────────────────────────
        // Metal 4 Render Pass Descriptor 획득
        // ────────────────────────────────────────────────────────────────────
        guard let renderPassDescriptor = view.currentMTL4RenderPassDescriptor,
              let drawable = view.currentDrawable else {
            return
        }

        // ────────────────────────────────────────────────────────────────────
        // 1. 이전 프레임 완료 대기 (Triple Buffering 동기화)
        // ────────────────────────────────────────────────────────────────────
        // Frame N을 렌더링하려면 Frame N-3이 완료되어야 합니다.
        // 이를 통해 해당 프레임의 리소스(유니폼 버퍼 등)를 안전하게 재사용할 수 있습니다.
        if frameIndex >= maxFramesInFlight {
            let valueToWait = frameIndex - maxFramesInFlight
            frameCompletionEvent.wait(untilSignaledValue: valueToWait, timeoutMS: 8)
        }

        // ────────────────────────────────────────────────────────────────────
        // 2. 애니메이션 업데이트
        // ────────────────────────────────────────────────────────────────────
        rotation += 0.02  // 매 프레임 약 1.1도 회전

        // ────────────────────────────────────────────────────────────────────
        // 3. 변환 행렬 계산
        // ────────────────────────────────────────────────────────────────────
        let aspect = Float(view.drawableSize.width / view.drawableSize.height)

        // Model Matrix: Y축 회전
        let modelMatrix = rotationY(rotation)

        // View Matrix: 카메라 설정
        // - 카메라 위치: (0, 0, -3) - 삼각형 앞에 위치
        // - 바라보는 점: (0, 0, 0) - 원점
        // - 위쪽 방향: (0, 1, 0) - Y축이 위
        let eye = SIMD3<Float>(0, 0, -3)
        let target = SIMD3<Float>(0, 0, 0)
        let up = SIMD3<Float>(0, 1, 0)
        let viewMatrix = lookAtLH(eye: eye, target: target, up: up)

        // Projection Matrix: 원근 투영
        // - FOV: 45도 (π/4 라디안)
        // - Near plane: 0.1
        // - Far plane: 100
        let projectionMatrix = perspectiveProjectionLH(
            fovYRadians: Float.pi / 4,
            aspect: aspect,
            nearZ: 0.1,
            farZ: 100
        )

        // ────────────────────────────────────────────────────────────────────
        // 4. 유니폼 버퍼 업데이트
        // ────────────────────────────────────────────────────────────────────
        var uniforms = Uniforms(
            modelMatrix: modelMatrix,
            viewMatrix: viewMatrix,
            projectionMatrix: projectionMatrix
        )

        let currentUniformBuffer = uniformBuffers[Int(frameIndex % maxFramesInFlight)]
        currentUniformBuffer.contents().copyMemory(
            from: &uniforms,
            byteCount: MemoryLayout<Uniforms>.stride
        )

        // ────────────────────────────────────────────────────────────────────
        // 5. Command Allocator 리셋 및 Command Buffer 시작
        // ────────────────────────────────────────────────────────────────────
        let allocator = commandAllocators[Int(frameIndex % maxFramesInFlight)]
        allocator.reset()  // 이전 프레임의 커맨드 데이터 해제

        commandBuffer.beginCommandBuffer(allocator: allocator)

        // ────────────────────────────────────────────────────────────────────
        // 6. Render Command Encoder 생성 및 설정
        // ────────────────────────────────────────────────────────────────────
        let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)!

        // Front-face 설정 (CCW = Counter-Clockwise)
        renderEncoder.setFrontFacing(.counterClockwise)

        // 깊이 테스트 설정
        renderEncoder.setDepthStencilState(depthStencilState)

        // 파이프라인 상태 설정
        renderEncoder.setRenderPipelineState(pipelineState)

        // ────────────────────────────────────────────────────────────────────
        // 7. Metal 4 Argument Table을 통한 리소스 바인딩
        // ────────────────────────────────────────────────────────────────────
        // 기존 Metal: renderEncoder.setVertexBuffer(buffer, offset:, index:)
        // Metal 4: argumentTable.setAddress(buffer.gpuAddress, index:)
        //          renderEncoder.setArgumentTable(table, stages:)
        vertexArgumentTable.setAddress(vertexBuffer.gpuAddress, index: 0)
        vertexArgumentTable.setAddress(currentUniformBuffer.gpuAddress, index: 1)
        renderEncoder.setArgumentTable(vertexArgumentTable, stages: .vertex)

        // ────────────────────────────────────────────────────────────────────
        // 8. 삼각형 그리기
        // ────────────────────────────────────────────────────────────────────
        renderEncoder.drawPrimitives(
            primitiveType: .triangle,
            vertexStart: 0,
            vertexCount: 3
        )

        renderEncoder.endEncoding()

        // ────────────────────────────────────────────────────────────────────
        // 9. Command Buffer 종료 및 제출
        // ────────────────────────────────────────────────────────────────────
        commandBuffer.endCommandBuffer()

        // Metal 4 방식의 Drawable 동기화 및 제출
        commandQueue.waitForDrawable(drawable)    // Drawable 준비 대기
        commandQueue.commit([commandBuffer])       // GPU에 커맨드 제출
        commandQueue.signalDrawable(drawable)      // Drawable 완료 시그널

        // ────────────────────────────────────────────────────────────────────
        // 10. 프레임 완료 시그널
        // ────────────────────────────────────────────────────────────────────
        // 다음 프레임에서 이 프레임의 리소스를 재사용할 수 있음을 알림
        commandQueue.signalEvent(frameCompletionEvent, value: frameIndex)

        // 프레임 인덱스 증가 (다음 프레임 준비)
        frameIndex += 1
        
        drawable.present()                         // 화면에 표시
    }
}


// ════════════════════════════════════════════════════════════════════════════
// MARK: - Legacy Metal Renderer (Fallback)
// ════════════════════════════════════════════════════════════════════════════

/// 기존 Metal API 기반 렌더러 (하위 호환성)
///
/// macOS 26.0 미만, iOS 26.0 미만 시스템에서 사용됩니다.
/// Metal 4 API 대신 기존 Metal API를 사용하여 동일한 결과를 렌더링합니다.
///
/// ## Metal 4와의 주요 차이점
///
/// | 기능 | Legacy Metal | Metal 4 |
/// |------|--------------|---------|
/// | Command Queue | MTLCommandQueue | MTL4CommandQueue |
/// | Command Buffer | 매 프레임 생성 | 재사용 + Allocator |
/// | Resource Binding | setVertexBuffer() | ArgumentTable |
/// | Pipeline | device.makeRenderPipelineState() | compiler.makeRenderPipelineState() |
/// | Memory | 암시적 관리 | ResidencySet |
///
/// - Note: 이 렌더러는 Metal 4가 지원되지 않는 환경에서 폴백으로 사용됩니다.
class LegacyMetalRenderer: NSObject, MTKViewDelegate {

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Properties
    // ════════════════════════════════════════════════════════════════════════

    /// Metal 디바이스
    let device: MTLDevice

    /// 커맨드 큐 (기존 Metal API)
    let commandQueue: MTLCommandQueue

    /// 렌더 파이프라인 상태
    var pipelineState: MTLRenderPipelineState!

    /// 버텍스 버퍼
    var vertexBuffer: MTLBuffer!

    /// 유니폼 버퍼 (단일 - 동기 렌더링)
    var uniformBuffer: MTLBuffer!

    /// 현재 회전 각도
    var rotation: Float = 0

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Initialization
    // ════════════════════════════════════════════════════════════════════════

    /// 레거시 렌더러 초기화
    ///
    /// - Parameter mtkView: 렌더링 결과를 표시할 MetalKit 뷰
    /// - Returns: 초기화된 렌더러, 실패 시 nil
    init?(mtkView: MTKView) {
        guard let device = MTLCreateSystemDefaultDevice(),
              let commandQueue = device.makeCommandQueue() else {
            return nil
        }

        self.device = device
        self.commandQueue = commandQueue

        mtkView.device = device
        mtkView.clearColor = MTLClearColor(red: 0.1, green: 0.1, blue: 0.1, alpha: 1.0)
        mtkView.depthStencilPixelFormat = .depth32Float

        super.init()

        buildPipelineState(mtkView: mtkView)
        buildBuffers()
    }

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Resource Building
    // ════════════════════════════════════════════════════════════════════════

    /// 파이프라인 상태 생성 (기존 Metal 방식)
    private func buildPipelineState(mtkView: MTKView) {
        guard let library = device.makeDefaultLibrary() else {
            fatalError("❌ 기본 Metal 라이브러리를 찾을 수 없습니다.")
        }

        // 기존 Metal 방식: makeFunction()으로 직접 함수 획득
        let vertexFunction = library.makeFunction(name: "vertexShader")
        let fragmentFunction = library.makeFunction(name: "fragmentShader")

        let pipelineDescriptor = MTLRenderPipelineDescriptor()
        pipelineDescriptor.vertexFunction = vertexFunction
        pipelineDescriptor.fragmentFunction = fragmentFunction
        pipelineDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat
        pipelineDescriptor.depthAttachmentPixelFormat = mtkView.depthStencilPixelFormat

        // 기존 Metal 방식: device에서 직접 파이프라인 생성
        do {
            pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)
        } catch {
            fatalError("❌ 파이프라인 상태 생성 실패: \(error)")
        }
    }

    /// GPU 버퍼 생성
    private func buildBuffers() {
        // 삼각형 버텍스 데이터
        let vertices: [Vertex] = [
            Vertex(position: SIMD3<Float>(0.0, 0.5, 0.0), color: SIMD4<Float>(1.0, 0.0, 0.0, 1.0)),
            Vertex(position: SIMD3<Float>(0.5, -0.5, 0.0), color: SIMD4<Float>(0.0, 1.0, 0.0, 1.0)),
            Vertex(position: SIMD3<Float>(-0.5, -0.5, 0.0), color: SIMD4<Float>(0.0, 0.0, 1.0, 1.0))
        ]

        vertexBuffer = device.makeBuffer(
            bytes: vertices,
            length: MemoryLayout<Vertex>.stride * vertices.count,
            options: .storageModeShared
        )

        uniformBuffer = device.makeBuffer(
            length: MemoryLayout<Uniforms>.stride,
            options: .storageModeShared
        )
    }

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - Matrix Functions
    // ════════════════════════════════════════════════════════════════════════

    /// 왼손 좌표계 원근 투영 행렬 (Metal4Renderer와 동일)
    func perspectiveProjectionLH(fovYRadians fovy: Float,
                                  aspect: Float,
                                  nearZ: Float,
                                  farZ: Float) -> float4x4 {
        let yScale = 1 / tan(fovy * 0.5)
        let xScale = yScale / aspect
        let zRange = farZ - nearZ

        return float4x4(columns: (
            SIMD4<Float>(xScale, 0, 0, 0),
            SIMD4<Float>(0, yScale, 0, 0),
            SIMD4<Float>(0, 0, farZ / zRange, 1),
            SIMD4<Float>(0, 0, -nearZ * farZ / zRange, 0)
        ))
    }

    /// 왼손 좌표계 Look-At 뷰 행렬 (Metal4Renderer와 동일)
    func lookAtLH(eye: SIMD3<Float>,
                  target: SIMD3<Float>,
                  up: SIMD3<Float>) -> float4x4 {
        let zAxis = normalize(target - eye)
        let xAxis = normalize(cross(up, zAxis))
        let yAxis = cross(zAxis, xAxis)

        return float4x4(columns: (
            SIMD4<Float>(xAxis.x, yAxis.x, zAxis.x, 0),
            SIMD4<Float>(xAxis.y, yAxis.y, zAxis.y, 0),
            SIMD4<Float>(xAxis.z, yAxis.z, zAxis.z, 0),
            SIMD4<Float>(-dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1)
        ))
    }

    /// Y축 회전 행렬 (Metal4Renderer와 동일)
    func rotationY(_ angle: Float) -> float4x4 {
        let c = cos(angle)
        let s = sin(angle)

        return float4x4(columns: (
            SIMD4<Float>(c, 0, -s, 0),
            SIMD4<Float>(0, 1, 0, 0),
            SIMD4<Float>(s, 0, c, 0),
            SIMD4<Float>(0, 0, 0, 1)
        ))
    }

    // ════════════════════════════════════════════════════════════════════════
    // MARK: - MTKViewDelegate
    // ════════════════════════════════════════════════════════════════════════

    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {}

    /// 프레임 렌더링 (기존 Metal 방식)
    func draw(in view: MTKView) {
        // 렌더 패스 및 커맨드 버퍼 획득
        guard let drawable = view.currentDrawable,
              let renderPassDescriptor = view.currentRenderPassDescriptor,
              let commandBuffer = commandQueue.makeCommandBuffer(),
              let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor) else {
            return
        }

        // 회전 업데이트
        rotation += 0.01

        // 변환 행렬 계산
        let aspect = Float(view.drawableSize.width / view.drawableSize.height)
        let modelMatrix = rotationY(rotation)

        let eye = SIMD3<Float>(0, 0, -3)
        let target = SIMD3<Float>(0, 0, 0)
        let up = SIMD3<Float>(0, 1, 0)
        let viewMatrix = lookAtLH(eye: eye, target: target, up: up)

        let projectionMatrix = perspectiveProjectionLH(
            fovYRadians: Float.pi / 4,
            aspect: aspect,
            nearZ: 0.1,
            farZ: 100
        )

        // 유니폼 버퍼 업데이트
        var uniforms = Uniforms(
            modelMatrix: modelMatrix,
            viewMatrix: viewMatrix,
            projectionMatrix: projectionMatrix
        )
        uniformBuffer.contents().copyMemory(from: &uniforms, byteCount: MemoryLayout<Uniforms>.stride)

        // 렌더링
        renderEncoder.setRenderPipelineState(pipelineState)

        // 기존 Metal 방식: setVertexBuffer()
        renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)
        renderEncoder.setVertexBuffer(uniformBuffer, offset: 0, index: 1)

        renderEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3)

        renderEncoder.endEncoding()

        // 기존 Metal 방식: present() 후 commit()
        commandBuffer.present(drawable)
        commandBuffer.commit()
    }
}
