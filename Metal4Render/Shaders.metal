//
//  Shaders.metal
//  Metal4Render
//
//  Metal 4 기반 삼각형 렌더링을 위한 GPU 셰이더
//
//  이 파일은 Metal Shading Language (MSL)로 작성되었으며,
//  GPU에서 실행되는 버텍스 셰이더와 프래그먼트 셰이더를 정의합니다.
//
//  ┌─────────────────────────────────────────────────────────────────┐
//  │                     렌더링 파이프라인 개요                         │
//  ├─────────────────────────────────────────────────────────────────┤
//  │                                                                 │
//  │   [Vertex Data]  ──▶  [Vertex Shader]  ──▶  [Rasterizer]       │
//  │        │                    │                    │              │
//  │        │                    ▼                    ▼              │
//  │        │              클립 공간 좌표        프래그먼트 생성        │
//  │        │              (Clip Space)                              │
//  │        │                                         │              │
//  │        │                                         ▼              │
//  │        │                              [Fragment Shader]         │
//  │        │                                         │              │
//  │        │                                         ▼              │
//  │        └─────────────────────────────────▶  [Frame Buffer]      │
//  │                                                                 │
//  └─────────────────────────────────────────────────────────────────┘
//
//  좌표계 설명 (Left-Hand Coordinate System):
//  ──────────────────────────────────────────
//
//       +Y (위)
//        │
//        │
//        │
//        │
//        └──────────── +X (오른쪽)
//       ╱
//      ╱
//     ╱
//    +Z (화면 안쪽, 멀어지는 방향)
//
//  - X축: 오른쪽이 양의 방향
//  - Y축: 위쪽이 양의 방향
//  - Z축: 화면 안쪽(멀어지는 방향)이 양의 방향 (왼손 좌표계의 특징)
//
//  Metal 4의 주요 변경사항:
//  ─────────────────────────
//  Metal 4에서는 Argument Table을 통해 버퍼를 바인딩하므로,
//  셰이더에서는 device 포인터를 통해 버퍼에 접근합니다.
//  이는 기존의 [[buffer(n)]] 어트리뷰트 방식보다 더 유연한 리소스 바인딩을 가능하게 합니다.
//

#include <metal_stdlib>
using namespace metal;

// ============================================================================
// MARK: - 데이터 구조체 정의
// ============================================================================

/// 버텍스 데이터 구조체
///
/// GPU 메모리에 저장된 각 버텍스(정점)의 데이터를 정의합니다.
/// Swift 측의 `Vertex` 구조체와 메모리 레이아웃이 일치해야 합니다.
///
/// 메모리 레이아웃 (28 bytes per vertex):
/// ┌────────────────────────────────────────────────────────────┐
/// │ position (float3)  │ color (float4)                       │
/// │ 12 bytes           │ 16 bytes                             │
/// │ [x, y, z]          │ [r, g, b, a]                         │
/// └────────────────────────────────────────────────────────────┘
///
/// - Note: float3는 실제로 16바이트로 정렬될 수 있으므로,
///         Swift 측에서 SIMD3<Float>를 사용할 때 stride를 확인해야 합니다.
struct Vertex {
    /// 3D 공간에서의 버텍스 위치 (로컬/모델 좌표계)
    /// - x: 좌우 위치 (-1.0 ~ 1.0, 왼쪽이 음수)
    /// - y: 상하 위치 (-1.0 ~ 1.0, 아래가 음수)
    /// - z: 깊이 위치 (0.0 ~ 1.0, 가까운 곳이 0)
    float3 position;

    /// 버텍스 색상 (RGBA 형식)
    /// - r: 빨간색 강도 (0.0 ~ 1.0)
    /// - g: 초록색 강도 (0.0 ~ 1.0)
    /// - b: 파란색 강도 (0.0 ~ 1.0)
    /// - a: 불투명도 (0.0 = 투명, 1.0 = 불투명)
    float4 color;
};

/// 버텍스 셰이더 출력 / 프래그먼트 셰이더 입력 구조체
///
/// 버텍스 셰이더에서 처리된 결과를 프래그먼트 셰이더로 전달합니다.
/// GPU의 래스터라이저가 이 데이터를 보간(interpolation)하여
/// 각 프래그먼트(픽셀 후보)에 대한 값을 생성합니다.
///
/// 보간 과정 예시 (삼각형 내부의 한 점 P):
/// ┌─────────────────────────────────────────────┐
/// │            V0 (빨강)                         │
/// │              ╱╲                              │
/// │             ╱  ╲                             │
/// │            ╱ P  ╲  ← P의 색상은 V0, V1, V2의 │
/// │           ╱      ╲    가중 평균으로 계산됨     │
/// │          ╱________╲                          │
/// │    V2 (파랑)    V1 (초록)                     │
/// └─────────────────────────────────────────────┘
struct VertexOut {
    /// 클립 공간(Clip Space) 좌표
    ///
    /// [[position]] 어트리뷰트는 이 값이 버텍스의 최종 위치임을 GPU에 알립니다.
    /// GPU는 이 좌표를 사용하여:
    /// 1. 원근 분할 (Perspective Division): xyz / w
    /// 2. 뷰포트 변환 (Viewport Transform): NDC → 화면 좌표
    /// 3. 클리핑 (Clipping): 화면 밖의 지오메트리 제거
    ///
    /// 클립 공간 좌표 범위:
    /// - x: -w ~ +w (나중에 -1 ~ +1로 정규화)
    /// - y: -w ~ +w (나중에 -1 ~ +1로 정규화)
    /// - z: 0 ~ +w  (Metal의 깊이 범위는 0 ~ 1)
    /// - w: 원근 분할에 사용되는 동차 좌표
    float4 position [[position]];

    /// 보간된 버텍스 색상
    ///
    /// 래스터라이저가 삼각형의 세 버텍스 색상을 무게중심 좌표
    /// (Barycentric Coordinates)를 사용하여 부드럽게 보간합니다.
    /// 이를 통해 그라디언트 효과가 자연스럽게 생성됩니다.
    float4 color;
};

/// 유니폼(Uniform) 데이터 구조체
///
/// 모든 버텍스에 동일하게 적용되는 변환 행렬들을 포함합니다.
/// "Uniform"이라는 이름은 모든 셰이더 호출에서 값이 균일(uniform)하기 때문입니다.
///
/// 변환 파이프라인:
/// ┌─────────────────────────────────────────────────────────────────────────┐
/// │                                                                         │
/// │   [로컬 좌표]  ─── Model ───▶  [월드 좌표]  ─── View ───▶  [뷰 좌표]    │
/// │   (Local)       Matrix        (World)       Matrix       (View/Eye)    │
/// │                                                                         │
/// │                                    │                                    │
/// │                                    ▼                                    │
/// │                              Projection                                 │
/// │                                Matrix                                   │
/// │                                    │                                    │
/// │                                    ▼                                    │
/// │                              [클립 좌표]                                 │
/// │                              (Clip Space)                               │
/// │                                                                         │
/// └─────────────────────────────────────────────────────────────────────────┘
///
/// 메모리 레이아웃 (192 bytes):
/// - modelMatrix:      64 bytes (4x4 floats)
/// - viewMatrix:       64 bytes (4x4 floats)
/// - projectionMatrix: 64 bytes (4x4 floats)
struct Uniforms {
    /// 모델 변환 행렬 (Model Matrix)
    ///
    /// 오브젝트의 로컬 좌표를 월드 좌표로 변환합니다.
    /// 이 행렬은 다음 변환들의 조합일 수 있습니다:
    /// - 이동 (Translation): 오브젝트 위치 이동
    /// - 회전 (Rotation): 오브젝트 방향 변경
    /// - 스케일 (Scale): 오브젝트 크기 변경
    ///
    /// 예시 (Y축 회전):
    /// ┌                    ┐
    /// │ cos(θ)  0  -sin(θ) 0 │
    /// │   0     1     0    0 │
    /// │ sin(θ)  0   cos(θ) 0 │
    /// │   0     0     0    1 │
    /// └                    ┘
    float4x4 modelMatrix;

    /// 뷰 변환 행렬 (View Matrix)
    ///
    /// 월드 좌표를 카메라(눈) 기준 좌표로 변환합니다.
    /// 실제로는 카메라를 원점에 고정하고 전체 월드를 역방향으로 변환합니다.
    ///
    /// lookAt 함수로 생성되며 다음을 정의합니다:
    /// - eye: 카메라 위치
    /// - target: 카메라가 바라보는 지점
    /// - up: 카메라의 위쪽 방향
    ///
    /// 왼손 좌표계에서 카메라는 +Z 방향을 바라봅니다.
    float4x4 viewMatrix;

    /// 투영 변환 행렬 (Projection Matrix)
    ///
    /// 3D 뷰 좌표를 2D 클립 좌표로 변환합니다.
    /// 원근 투영(Perspective Projection)을 사용하여
    /// 멀리 있는 물체가 작게 보이는 효과를 구현합니다.
    ///
    /// 원근 투영의 시각적 효과:
    /// ┌─────────────────────────────────────┐
    /// │     Near Plane    Far Plane         │
    /// │         │             │             │
    /// │    ┌────┼────┐   ┌────┼────┐        │
    /// │    │    │    │   │    │    │        │
    /// │ Eye ════╪════════════╪════ ▶ +Z     │
    /// │    │    │    │   │    │    │        │
    /// │    └────┼────┘   └────┼────┘        │
    /// │         │             │             │
    /// │    (크게 보임)    (작게 보임)         │
    /// └─────────────────────────────────────┘
    ///
    /// 주요 파라미터:
    /// - FOV (Field of View): 시야각 (라디안)
    /// - Aspect Ratio: 화면 가로/세로 비율
    /// - Near/Far: 클리핑 평면 거리
    float4x4 projectionMatrix;
};


// ============================================================================
// MARK: - 버텍스 셰이더 (Vertex Shader)
// ============================================================================

/// 버텍스 셰이더 함수
///
/// GPU에서 각 버텍스(정점)마다 한 번씩 실행되며,
/// 3D 모델 좌표를 화면에 표시할 수 있는 클립 좌표로 변환합니다.
///
/// ## 실행 흐름
///
/// ```
/// 각 버텍스에 대해:
/// 1. vertex_id를 사용하여 버텍스 데이터 읽기
/// 2. MVP 행렬 계산 (Projection × View × Model)
/// 3. 버텍스 위치에 MVP 행렬 적용
/// 4. 변환된 위치와 색상을 VertexOut으로 출력
/// ```
///
/// ## 좌표 변환 상세
///
/// MVP 행렬 적용 순서 (오른쪽에서 왼쪽으로 읽음):
/// ```
/// clipPosition = projectionMatrix × viewMatrix × modelMatrix × localPosition
///              = P × V × M × v
/// ```
///
/// 각 단계의 좌표 공간:
/// 1. localPosition (float4): 모델의 로컬 좌표 (w=1.0으로 동차좌표 생성)
/// 2. M × v: 월드 좌표 (모델이 월드에 배치된 위치)
/// 3. V × M × v: 뷰 좌표 (카메라 기준 좌표)
/// 4. P × V × M × v: 클립 좌표 (투영 적용)
///
/// ## Metal 4 특징
///
/// Metal 4에서는 `[[buffer(n)]]` 대신 device 포인터를 사용합니다.
/// Argument Table을 통해 버퍼의 GPU 주소가 전달되므로,
/// 셰이더는 해당 주소에서 직접 데이터를 읽습니다.
///
/// - Parameters:
///   - vertexID: 현재 처리 중인 버텍스의 인덱스 (0부터 시작)
///               [[vertex_id]] 어트리뷰트로 GPU가 자동 제공
///   - vertices: 버텍스 배열에 대한 디바이스 포인터
///               Argument Table의 index 0에 바인딩된 버퍼
///   - uniforms: 유니폼 데이터에 대한 디바이스 포인터
///               Argument Table의 index 1에 바인딩된 버퍼
///
/// - Returns: 변환된 버텍스 데이터 (위치 + 색상)
///
/// - Note: 이 셰이더는 삼각형의 3개 버텍스에 대해 각각 한 번씩,
///         총 3번 실행됩니다.
vertex VertexOut vertexShader(
    uint vertexID [[vertex_id]],
    const device Vertex* vertices [[buffer(0)]],
    const device Uniforms* uniforms [[buffer(1)]]
) {
    // 출력 구조체 초기화
    VertexOut out;

    // ────────────────────────────────────────────────────────────────
    // MVP (Model-View-Projection) 행렬 계산
    // ────────────────────────────────────────────────────────────────
    //
    // 행렬 곱셈 순서가 중요합니다!
    // GPU에서의 행렬 곱셈은 오른쪽에서 왼쪽으로 적용됩니다:
    //
    //   mvp = P × V × M
    //
    // 버텍스에 적용할 때:
    //   result = mvp × vertex = P × (V × (M × vertex))
    //
    // 이는 다음 순서로 변환됨을 의미합니다:
    //   1. Model: 로컬 → 월드
    //   2. View: 월드 → 카메라
    //   3. Projection: 카메라 → 클립
    //
    float4x4 mvp = uniforms->projectionMatrix * uniforms->viewMatrix * uniforms->modelMatrix;

    // ────────────────────────────────────────────────────────────────
    // 버텍스 위치 변환
    // ────────────────────────────────────────────────────────────────
    //
    // float3 → float4 변환:
    // - w = 1.0을 추가하여 동차 좌표(Homogeneous Coordinates)로 만듦
    // - 동차 좌표는 행렬 곱셈으로 이동(translation)을 표현할 수 있게 함
    //
    // 변환 후 클립 좌표의 의미:
    // - x, y: 화면 상의 위치 (나중에 w로 나눠서 NDC로 변환)
    // - z: 깊이 값 (깊이 테스트에 사용)
    // - w: 원근 분할을 위한 값 (보통 카메라까지의 거리와 관련)
    //
    out.position = mvp * float4(vertices[vertexID].position, 1.0);

    // ────────────────────────────────────────────────────────────────
    // 버텍스 색상 전달 (Pass-through)
    // ────────────────────────────────────────────────────────────────
    //
    // 색상은 변환 없이 그대로 전달됩니다.
    // 래스터라이저가 삼각형 내부의 각 픽셀에 대해
    // 세 버텍스의 색상을 자동으로 보간합니다.
    //
    out.color = vertices[vertexID].color;

    return out;
}


// ============================================================================
// MARK: - 프래그먼트 셰이더 (Fragment Shader)
// ============================================================================

/// 프래그먼트 셰이더 함수
///
/// GPU에서 래스터화된 각 프래그먼트(픽셀 후보)마다 실행되며,
/// 최종 픽셀 색상을 결정합니다.
///
/// ## 프래그먼트란?
///
/// 프래그먼트는 잠재적인 픽셀입니다. 삼각형이 화면의 픽셀 그리드와
/// 교차하는 모든 위치에서 프래그먼트가 생성됩니다.
///
/// ```
/// 삼각형과 픽셀 그리드:
/// ┌───┬───┬───┬───┬───┐
/// │   │ ▲ │   │   │   │  ▲ = 삼각형 꼭짓점
/// ├───┼─╱─┼───┼───┼───┤
/// │  ╱│███│╲  │   │   │  ███ = 생성된 프래그먼트
/// ├─╱─┼───┼─╲─┼───┼───┤
/// │███│███│███│╲  │   │  각 프래그먼트마다
/// ├───┼───┼───┼─╲─┼───┤  이 셰이더가 실행됨
/// │   │   │   │  ╲│   │
/// └───┴───┴───┴───┴───┘
/// ```
///
/// ## 색상 보간
///
/// 입력으로 받는 `in.color`는 버텍스 셰이더에서 출력된 세 버텍스의
/// 색상이 현재 프래그먼트의 위치에 맞게 보간된 값입니다.
///
/// 보간 공식 (무게중심 좌표 사용):
/// ```
/// color = w0 × color0 + w1 × color1 + w2 × color2
/// ```
/// 여기서 w0 + w1 + w2 = 1.0
///
/// ## 이 셰이더가 하는 일
///
/// 현재는 단순히 보간된 색상을 그대로 출력합니다.
/// 더 복잡한 셰이더에서는 여기서:
/// - 텍스처 샘플링
/// - 조명 계산 (Phong, PBR 등)
/// - 노말 매핑
/// - 그림자 계산
/// - 후처리 효과
/// 등을 수행할 수 있습니다.
///
/// - Parameter in: 래스터라이저가 보간한 버텍스 데이터
///                 [[stage_in]] 어트리뷰트는 이것이 이전 스테이지의
///                 출력임을 나타냅니다.
///
/// - Returns: 최종 픽셀 색상 (RGBA)
///            이 값이 프레임 버퍼에 기록됩니다.
///
/// - Note: 삼각형 내부의 모든 픽셀에 대해 실행되므로,
///         작은 삼각형이라도 수백~수천 번 실행될 수 있습니다.
fragment float4 fragmentShader(VertexOut in [[stage_in]]) {
    // ────────────────────────────────────────────────────────────────
    // 최종 색상 출력
    // ────────────────────────────────────────────────────────────────
    //
    // 보간된 색상을 그대로 반환합니다.
    // 결과적으로 세 버텍스(빨강, 초록, 파랑)의 색상이
    // 삼각형 전체에 걸쳐 부드럽게 그라디언트로 표현됩니다.
    //
    // 출력 형식: float4(R, G, B, A)
    // - 각 채널은 0.0 ~ 1.0 범위
    // - 프레임 버퍼의 픽셀 포맷에 맞게 자동 변환됨
    //   (예: BGRA8Unorm_sRGB의 경우 0~255 정수로 변환)
    //
    return in.color;
}
