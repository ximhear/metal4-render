//
//  Shaders.metal
//  Metal4Render
//
//  Metal 4 기반 삼각형 렌더링을 위한 GPU 셰이더
//
//  이 파일은 Metal Shading Language (MSL)로 작성되었으며,
//  GPU에서 실행되는 버텍스 셰이더와 프래그먼트 셰이더를 정의합니다.
//
//
//  ╔═════════════════════════════════════════════════════════════════════════════╗
//  ║                                                                             ║
//  ║              M E T A L   S H A D I N G   L A N G U A G E                    ║
//  ║                        완 전   가 이 드                                       ║
//  ║                                                                             ║
//  ╚═════════════════════════════════════════════════════════════════════════════╝
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제1장: Metal Shading Language(MSL) 소개
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  MSL은 Apple의 GPU 프로그래밍 언어로, C++14를 기반으로 합니다.
//  GPU에서 실행되는 그래픽 및 컴퓨트 셰이더를 작성하는 데 사용됩니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                          MSL vs 다른 셰이딩 언어                                │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   ┌─────────────┬────────────────┬────────────────┬──────────────────┐       │
//  │   │    언어      │   플랫폼        │   기반 언어     │   특징            │       │
//  │   ├─────────────┼────────────────┼────────────────┼──────────────────┤       │
//  │   │ MSL         │ Apple (Metal)  │ C++14          │ 타입 안전, 현대적  │       │
//  │   │ GLSL        │ OpenGL/Vulkan  │ C-like         │ 광범위한 호환성    │       │
//  │   │ HLSL        │ DirectX        │ C-like         │ Windows 게임      │       │
//  │   │ WGSL        │ WebGPU         │ Rust-like      │ 웹 그래픽         │       │
//  │   └─────────────┴────────────────┴────────────────┴──────────────────┘       │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  MSL의 주요 특징:
//  ────────────────
//  1. C++14 기반: 템플릿, 클래스, 람다 등 C++ 기능 사용 가능
//  2. 타입 안전: 컴파일 타임에 타입 검사
//  3. 어트리뷰트 시스템: [[...]] 구문으로 GPU 특화 의미 부여
//  4. 사전 컴파일: .metal 파일은 빌드 시 컴파일되어 .metallib로 번들됨
//  5. GPU 최적화: Apple Silicon에 최적화된 코드 생성
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제2장: GPU 실행 모델의 이해
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  GPU는 수천 개의 스레드를 동시에 실행하는 대규모 병렬 프로세서입니다.
//  셰이더 코드는 각 스레드에서 독립적으로 실행됩니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                          GPU 스레드 실행 모델                                  │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   버텍스 셰이더 실행:                                                          │
//  │   ─────────────────                                                           │
//  │                                                                               │
//  │   삼각형의 3개 버텍스 → 3개의 스레드가 동시에 실행                              │
//  │                                                                               │
//  │   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐                        │
//  │   │  Thread 0   │   │  Thread 1   │   │  Thread 2   │                        │
//  │   │ vertex_id=0 │   │ vertex_id=1 │   │ vertex_id=2 │                        │
//  │   │             │   │             │   │             │                        │
//  │   │ 빨강 버텍스  │   │ 초록 버텍스  │   │ 파랑 버텍스  │                        │
//  │   │ (0, 0.5, 0) │   │ (0.5,-0.5,0)│   │(-0.5,-0.5,0)│                        │
//  │   └──────┬──────┘   └──────┬──────┘   └──────┬──────┘                        │
//  │          │                 │                 │                                │
//  │          │    동시 실행     │                 │                                │
//  │          ▼                 ▼                 ▼                                │
//  │   ┌─────────────────────────────────────────────────┐                        │
//  │   │              래스터라이저 (Rasterizer)            │                        │
//  │   │         버텍스 출력을 프래그먼트로 변환            │                        │
//  │   └─────────────────────────────────────────────────┘                        │
//  │                                                                               │
//  │                                                                               │
//  │   프래그먼트 셰이더 실행:                                                      │
//  │   ─────────────────────                                                       │
//  │                                                                               │
//  │   삼각형이 100개의 픽셀을 덮음 → 100개의 스레드가 동시에 실행                   │
//  │                                                                               │
//  │   ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐                                 │
//  │   │T0 │T1 │T2 │T3 │T4 │T5 │T6 │T7 │T8 │...│  각 스레드가                     │
//  │   │   │   │   │   │   │   │   │   │   │   │  하나의 픽셀 처리                 │
//  │   └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘                                 │
//  │                                                                               │
//  │                                                                               │
//  │   SIMD 그룹 (Warp/Wave):                                                      │
//  │   ──────────────────────                                                      │
//  │                                                                               │
//  │   GPU는 스레드를 그룹(SIMD Group)으로 묶어서 실행합니다.                        │
//  │   Apple GPU에서는 보통 32개의 스레드가 하나의 SIMD 그룹을 형성합니다.            │
//  │                                                                               │
//  │   ┌──────────────────────────────────────────────────────────┐               │
//  │   │                    SIMD Group (32 threads)               │               │
//  │   │  ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐      │               │
//  │   │  │T0│T1│T2│T3│T4│T5│T6│T7│T8│T9│..│..│..│..│..│T31     │               │
//  │   │  └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘      │               │
//  │   │                                                          │               │
//  │   │  • 모든 스레드가 동일한 명령어를 동시에 실행 (SIMT)         │               │
//  │   │  • 분기가 있으면 모든 경로를 순차 실행 (분기 분산)          │               │
//  │   └──────────────────────────────────────────────────────────┘               │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  성능 팁: 분기 (if문) 피하기
//  ───────────────────────────
//  GPU에서 분기는 비효율적입니다. SIMD 그룹의 일부 스레드만 분기를 탈 경우,
//  나머지 스레드는 대기해야 합니다 (분기 분산, Branch Divergence).
//
//  // 나쁜 예 - 분기 발생
//  if (condition) {
//      result = expensiveCalculation1();
//  } else {
//      result = expensiveCalculation2();
//  }
//
//  // 좋은 예 - 분기 없음
//  result = mix(value1, value2, condition);  // 선형 보간으로 대체
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제3장: MSL 데이터 타입 상세
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  MSL은 GPU 연산에 최적화된 다양한 데이터 타입을 제공합니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            스칼라 타입 (Scalar Types)                          │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   ┌──────────────┬─────────────────┬──────────────────────────────────┐      │
//  │   │    타입       │     크기         │     설명                         │      │
//  │   ├──────────────┼─────────────────┼──────────────────────────────────┤      │
//  │   │ bool         │ 1 byte          │ true 또는 false                  │      │
//  │   │ char/uchar   │ 1 byte          │ 부호 있는/없는 8비트 정수         │      │
//  │   │ short/ushort │ 2 bytes         │ 부호 있는/없는 16비트 정수        │      │
//  │   │ int/uint     │ 4 bytes         │ 부호 있는/없는 32비트 정수        │      │
//  │   │ half         │ 2 bytes         │ 16비트 부동소수점 (FP16)         │      │
//  │   │ float        │ 4 bytes         │ 32비트 부동소수점 (FP32)         │      │
//  │   └──────────────┴─────────────────┴──────────────────────────────────┘      │
//  │                                                                               │
//  │   half vs float:                                                              │
//  │   ──────────────                                                              │
//  │   • half는 메모리와 대역폭을 절약하지만 정밀도가 낮음                           │
//  │   • 색상, 노말, UV 좌표 등에 half 사용 가능                                    │
//  │   • 위치 계산에는 float 권장                                                  │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            벡터 타입 (Vector Types)                            │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   벡터는 2, 3, 4개의 컴포넌트를 가질 수 있습니다.                               │
//  │                                                                               │
//  │   ┌──────────────┬────────────────────────────────────────────────────┐      │
//  │   │    타입       │     컴포넌트 접근 방법                              │      │
//  │   ├──────────────┼────────────────────────────────────────────────────┤      │
//  │   │ float2       │ .x, .y 또는 .r, .g                                 │      │
//  │   │ float3       │ .x, .y, .z 또는 .r, .g, .b 또는 .xyz               │      │
//  │   │ float4       │ .x, .y, .z, .w 또는 .r, .g, .b, .a 또는 .xyzw     │      │
//  │   │ half4        │ 동일 (16비트 버전)                                  │      │
//  │   │ int4         │ 동일 (정수 버전)                                    │      │
//  │   └──────────────┴────────────────────────────────────────────────────┘      │
//  │                                                                               │
//  │   스위즐링 (Swizzling):                                                       │
//  │   ─────────────────────                                                       │
//  │   벡터의 컴포넌트를 재배열하거나 선택할 수 있습니다.                            │
//  │                                                                               │
//  │   float4 color = float4(1.0, 0.5, 0.25, 1.0);                                │
//  │                                                                               │
//  │   color.rgb     // float3(1.0, 0.5, 0.25)  - RGB만 추출                      │
//  │   color.bgr     // float3(0.25, 0.5, 1.0)  - BGR 순서로 재배열               │
//  │   color.rrr     // float3(1.0, 1.0, 1.0)   - R 복제                          │
//  │   color.xy      // float2(1.0, 0.5)        - XY만 추출                       │
//  │   color.wzyx    // float4(1.0, 0.25, 0.5, 1.0) - 역순                        │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            행렬 타입 (Matrix Types)                            │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   Metal은 column-major 행렬을 사용합니다.                                      │
//  │                                                                               │
//  │   float4x4 matrix;                                                            │
//  │                                                                               │
//  │   메모리 레이아웃:                                                             │
//  │   ┌─────────────────────────────────────────────────────┐                    │
//  │   │    열 0       열 1       열 2       열 3             │                    │
//  │   │  ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐             │                    │
//  │   │  │m00  │   │m01  │   │m02  │   │m03  │  ← 행 0      │                    │
//  │   │  │m10  │   │m11  │   │m12  │   │m13  │  ← 행 1      │                    │
//  │   │  │m20  │   │m21  │   │m22  │   │m23  │  ← 행 2      │                    │
//  │   │  │m30  │   │m31  │   │m32  │   │m33  │  ← 행 3      │                    │
//  │   │  └─────┘   └─────┘   └─────┘   └─────┘             │                    │
//  │   │     ↓         ↓         ↓         ↓                 │                    │
//  │   │  [0][0]    [1][0]    [2][0]    [3][0]  ...          │                    │
//  │   │  [0][1]    [1][1]    [2][1]    [3][1]  ...          │                    │
//  │   │  [0][2]    [1][2]    [2][2]    [3][2]  ...          │                    │
//  │   │  [0][3]    [1][3]    [2][3]    [3][3]               │                    │
//  │   └─────────────────────────────────────────────────────┘                    │
//  │                                                                               │
//  │   matrix[열][행] 으로 접근                                                     │
//  │   matrix[0] = 첫 번째 열 (float4)                                             │
//  │                                                                               │
//  │   변환 적용:                                                                  │
//  │   ────────                                                                    │
//  │   float4 result = matrix * vector;  // 열벡터에 행렬 곱셈                     │
//  │                                                                               │
//  │   이는 수학적으로 다음과 같습니다:                                             │
//  │   result = matrix[0]*v.x + matrix[1]*v.y + matrix[2]*v.z + matrix[3]*v.w     │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제4장: 어트리뷰트 시스템 (Attributes)
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  MSL은 [[attribute]] 구문으로 GPU 특화 의미를 부여합니다.
//  이 어트리뷰트들은 GPU 하드웨어가 데이터를 어떻게 처리할지 알려줍니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            함수 한정자 (Function Qualifiers)                   │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   ┌────────────────┬───────────────────────────────────────────────────┐     │
//  │   │   한정자        │   설명                                             │     │
//  │   ├────────────────┼───────────────────────────────────────────────────┤     │
//  │   │ vertex         │ 버텍스 셰이더 함수                                 │     │
//  │   │ fragment       │ 프래그먼트 셰이더 함수                             │     │
//  │   │ kernel         │ 컴퓨트 셰이더 함수                                 │     │
//  │   │ [[visible]]    │ Metal 4: 다른 셰이더에서 호출 가능한 함수          │     │
//  │   └────────────────┴───────────────────────────────────────────────────┘     │
//  │                                                                               │
//  │   예시:                                                                       │
//  │   vertex VertexOut vertexShader(...) { }     // 버텍스 셰이더                 │
//  │   fragment float4 fragmentShader(...) { }    // 프래그먼트 셰이더             │
//  │   kernel void computeShader(...) { }         // 컴퓨트 셰이더                 │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            입력 어트리뷰트 (Input Attributes)                  │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   버텍스 셰이더 입력:                                                          │
//  │   ───────────────────                                                         │
//  │   ┌────────────────────┬─────────────────────────────────────────────────┐   │
//  │   │   어트리뷰트         │   설명                                          │   │
//  │   ├────────────────────┼─────────────────────────────────────────────────┤   │
//  │   │ [[vertex_id]]      │ 현재 버텍스의 인덱스 (0부터 시작)               │   │
//  │   │ [[instance_id]]    │ 현재 인스턴스의 인덱스 (인스턴싱 사용 시)       │   │
//  │   │ [[base_vertex]]    │ drawPrimitives의 baseVertex 값                 │   │
//  │   │ [[base_instance]]  │ 인스턴스 렌더링의 시작 인덱스                   │   │
//  │   │ [[buffer(n)]]      │ n번 버퍼에 바인딩된 데이터                      │   │
//  │   │ [[attribute(n)]]   │ 버텍스 디스크립터의 n번 속성                    │   │
//  │   └────────────────────┴─────────────────────────────────────────────────┘   │
//  │                                                                               │
//  │   프래그먼트 셰이더 입력:                                                      │
//  │   ─────────────────────                                                       │
//  │   ┌────────────────────┬─────────────────────────────────────────────────┐   │
//  │   │   어트리뷰트         │   설명                                          │   │
//  │   ├────────────────────┼─────────────────────────────────────────────────┤   │
//  │   │ [[stage_in]]       │ 버텍스 셰이더 출력을 받음 (래스터라이저가 보간)  │   │
//  │   │ [[position]]       │ 현재 프래그먼트의 윈도우 좌표 (읽기 전용)       │   │
//  │   │ [[front_facing]]   │ 전면인지 후면인지 (bool)                       │   │
//  │   │ [[sample_id]]      │ 멀티샘플링 시 샘플 인덱스                       │   │
//  │   │ [[buffer(n)]]      │ n번 버퍼에 바인딩된 데이터                      │   │
//  │   │ [[texture(n)]]     │ n번 텍스처                                     │   │
//  │   │ [[sampler(n)]]     │ n번 샘플러                                     │   │
//  │   └────────────────────┴─────────────────────────────────────────────────┘   │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            출력 어트리뷰트 (Output Attributes)                 │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   버텍스 셰이더 출력:                                                          │
//  │   ───────────────────                                                         │
//  │   ┌────────────────────┬─────────────────────────────────────────────────┐   │
//  │   │   어트리뷰트         │   설명                                          │   │
//  │   ├────────────────────┼─────────────────────────────────────────────────┤   │
//  │   │ [[position]]       │ 클립 공간 좌표 (필수)                           │   │
//  │   │ [[point_size]]     │ 포인트 프리미티브의 크기                        │   │
//  │   │ [[clip_distance]]  │ 사용자 정의 클리핑 평면과의 거리                │   │
//  │   └────────────────────┴─────────────────────────────────────────────────┘   │
//  │                                                                               │
//  │   [[position]]의 중요성:                                                      │
//  │   ─────────────────────                                                       │
//  │   • 버텍스 셰이더 출력 구조체에서 반드시 하나의 float4 멤버에 지정             │
//  │   • GPU가 이 값을 클리핑, 원근 분할, 뷰포트 변환에 사용                       │
//  │   • 클립 공간 좌표: (x, y, z, w)                                             │
//  │     - NDC로 변환: (x/w, y/w, z/w)                                            │
//  │     - Metal의 NDC 범위: x,y ∈ [-1,1], z ∈ [0,1]                             │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제5장: 메모리 공간 (Address Spaces)
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  MSL은 GPU 메모리의 다양한 영역을 구분합니다.
//  각 메모리 공간은 다른 특성과 용도를 가집니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            메모리 공간 종류                                    │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   ┌──────────────┬─────────────────┬────────────────────────────────────┐    │
//  │   │   공간        │   키워드         │   특징                              │    │
//  │   ├──────────────┼─────────────────┼────────────────────────────────────┤    │
//  │   │ Device       │ device          │ GPU 메인 메모리, 읽기/쓰기 가능     │    │
//  │   │ Constant     │ constant        │ 읽기 전용, 더 빠른 캐시 접근        │    │
//  │   │ Threadgroup  │ threadgroup     │ SIMD 그룹 내 공유 메모리            │    │
//  │   │ Thread       │ thread (기본)   │ 스레드 로컬 변수                    │    │
//  │   └──────────────┴─────────────────┴────────────────────────────────────┘    │
//  │                                                                               │
//  │   ┌─────────────────────────────────────────────────────────────────────┐    │
//  │   │                        GPU 메모리 계층 구조                          │    │
//  │   ├─────────────────────────────────────────────────────────────────────┤    │
//  │   │                                                                     │    │
//  │   │   속도: 빠름 ◀──────────────────────────────────────────▶ 느림       │    │
//  │   │   용량: 작음 ◀──────────────────────────────────────────▶ 큼         │    │
//  │   │                                                                     │    │
//  │   │   ┌──────────────┐                                                  │    │
//  │   │   │  Registers   │  스레드 로컬 변수 (가장 빠름)                     │    │
//  │   │   └──────┬───────┘                                                  │    │
//  │   │          ▼                                                          │    │
//  │   │   ┌──────────────┐                                                  │    │
//  │   │   │ Threadgroup  │  SIMD 그룹 공유 메모리 (수 KB)                   │    │
//  │   │   │   Memory     │                                                  │    │
//  │   │   └──────┬───────┘                                                  │    │
//  │   │          ▼                                                          │    │
//  │   │   ┌──────────────┐                                                  │    │
//  │   │   │   Constant   │  상수 데이터 캐시                                │    │
//  │   │   │    Cache     │                                                  │    │
//  │   │   └──────┬───────┘                                                  │    │
//  │   │          ▼                                                          │    │
//  │   │   ┌──────────────┐                                                  │    │
//  │   │   │   Device     │  GPU 메인 메모리 (GB 단위)                       │    │
//  │   │   │   Memory     │                                                  │    │
//  │   │   └──────────────┘                                                  │    │
//  │   │                                                                     │    │
//  │   └─────────────────────────────────────────────────────────────────────┘    │
//  │                                                                               │
//  │   사용 예시:                                                                  │
//  │   ────────                                                                    │
//  │                                                                               │
//  │   // Device 공간 - 대부분의 버퍼 데이터                                       │
//  │   vertex VertexOut myShader(                                                  │
//  │       const device Vertex* vertices [[buffer(0)]],  // 읽기 전용              │
//  │       device float* output [[buffer(1)]]            // 읽기/쓰기              │
//  │   )                                                                           │
//  │                                                                               │
//  │   // Constant 공간 - 자주 읽히는 작은 데이터                                   │
//  │   vertex VertexOut myShader(                                                  │
//  │       constant Uniforms& uniforms [[buffer(0)]]     // 참조로 전달            │
//  │   )                                                                           │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제6장: 텍스처와 샘플링
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  이 예제에서는 텍스처를 사용하지 않지만, 텍스처는 그래픽에서 핵심적인 요소입니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            텍스처 타입                                         │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   ┌────────────────────┬───────────────────────────────────────────────┐     │
//  │   │   타입              │   설명                                         │     │
//  │   ├────────────────────┼───────────────────────────────────────────────┤     │
//  │   │ texture1d<T>       │ 1D 텍스처 (그라디언트, LUT 등)                │     │
//  │   │ texture2d<T>       │ 2D 텍스처 (가장 일반적)                       │     │
//  │   │ texture3d<T>       │ 3D 텍스처 (볼륨 데이터)                       │     │
//  │   │ texturecube<T>     │ 큐브맵 텍스처 (환경 맵)                       │     │
//  │   │ texture2d_array<T> │ 2D 텍스처 배열 (스프라이트 시트)              │     │
//  │   │ texture2d_ms<T>    │ 멀티샘플 2D 텍스처 (MSAA)                     │     │
//  │   └────────────────────┴───────────────────────────────────────────────┘     │
//  │                                                                               │
//  │   T는 샘플 타입: float, half, int, uint 등                                   │
//  │                                                                               │
//  │   접근 한정자:                                                                │
//  │   ┌─────────────┬────────────────────────────────────────────────────┐       │
//  │   │   한정자     │   설명                                              │       │
//  │   ├─────────────┼────────────────────────────────────────────────────┤       │
//  │   │ sample      │ 샘플링으로 읽기 (기본)                              │       │
//  │   │ read        │ 좌표로 직접 읽기 (필터링 없음)                      │       │
//  │   │ write       │ 쓰기 전용 (컴퓨트/프래그먼트)                       │       │
//  │   │ read_write  │ 읽기/쓰기 모두                                      │       │
//  │   └─────────────┴────────────────────────────────────────────────────┘       │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            샘플러 (Sampler)                                    │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   샘플러는 텍스처에서 색상을 읽을 때 사용하는 필터링/래핑 설정입니다.           │
//  │                                                                               │
//  │   // 샘플러 선언 (셰이더 내)                                                  │
//  │   constexpr sampler textureSampler(                                           │
//  │       filter::linear,           // 선형 필터링 (부드럽게)                     │
//  │       mip_filter::linear,       // 밉맵 필터링                                │
//  │       address::repeat           // 반복 래핑                                  │
//  │   );                                                                          │
//  │                                                                               │
//  │   필터링 모드:                                                                │
//  │   ┌─────────────┬────────────────────────────────────────────────────┐       │
//  │   │   모드       │   효과                                              │       │
//  │   ├─────────────┼────────────────────────────────────────────────────┤       │
//  │   │ nearest     │ 가장 가까운 텍셀 (픽셀화된 느낌)                    │       │
//  │   │ linear      │ 이웃 텍셀들의 보간 (부드러움)                       │       │
//  │   └─────────────┴────────────────────────────────────────────────────┘       │
//  │                                                                               │
//  │   주소 모드 (UV 범위 밖 처리):                                                │
//  │   ┌─────────────────┬────────────────────────────────────────────────┐       │
//  │   │   모드           │   효과                                          │       │
//  │   ├─────────────────┼────────────────────────────────────────────────┤       │
//  │   │ repeat          │ 타일처럼 반복                                    │       │
//  │   │ mirrored_repeat │ 거울처럼 반복                                    │       │
//  │   │ clamp_to_edge   │ 가장자리 색상 유지                              │       │
//  │   │ clamp_to_zero   │ 투명/검정 반환                                  │       │
//  │   └─────────────────┴────────────────────────────────────────────────┘       │
//  │                                                                               │
//  │   텍스처 샘플링 예시:                                                         │
//  │   ─────────────────                                                           │
//  │   fragment float4 texturedFragment(                                           │
//  │       VertexOut in [[stage_in]],                                              │
//  │       texture2d<float> colorTexture [[texture(0)]],                           │
//  │       sampler texSampler [[sampler(0)]]                                       │
//  │   ) {                                                                         │
//  │       float4 color = colorTexture.sample(texSampler, in.texCoord);            │
//  │       return color;                                                           │
//  │   }                                                                           │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제7장: 내장 함수 (Built-in Functions)
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  MSL은 GPU에서 효율적으로 실행되는 다양한 내장 함수를 제공합니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            수학 함수                                           │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   삼각 함수:                                                                  │
//  │   sin(x), cos(x), tan(x)              // 기본 삼각 함수                       │
//  │   asin(x), acos(x), atan(x)           // 역삼각 함수                          │
//  │   sincos(x, &sin_val, &cos_val)       // sin과 cos 동시 계산 (최적화)         │
//  │                                                                               │
//  │   지수/로그:                                                                  │
//  │   exp(x), exp2(x)                     // e^x, 2^x                            │
//  │   log(x), log2(x), log10(x)           // 로그 함수                            │
//  │   pow(x, y)                           // x^y                                  │
//  │   sqrt(x), rsqrt(x)                   // 제곱근, 역제곱근                      │
//  │                                                                               │
//  │   보간/클램핑:                                                                │
//  │   mix(a, b, t)                        // 선형 보간: a*(1-t) + b*t             │
//  │   clamp(x, min, max)                  // 범위 제한                            │
//  │   saturate(x)                         // clamp(x, 0, 1)과 동일                │
//  │   step(edge, x)                       // x < edge ? 0 : 1                     │
//  │   smoothstep(e0, e1, x)               // 부드러운 계단 함수                    │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            벡터/행렬 함수                                      │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   벡터 연산:                                                                  │
//  │   dot(a, b)                           // 내적: a·b                            │
//  │   cross(a, b)                         // 외적: a×b (float3만)                 │
//  │   length(v)                           // 벡터 길이: |v|                       │
//  │   distance(a, b)                      // 두 점 사이 거리                      │
//  │   normalize(v)                        // 정규화: v/|v|                        │
//  │   reflect(I, N)                       // 반사 벡터                            │
//  │   refract(I, N, eta)                  // 굴절 벡터                            │
//  │   faceforward(N, I, Nref)             // 노말 방향 조정                       │
//  │                                                                               │
//  │   행렬 연산:                                                                  │
//  │   transpose(m)                        // 전치 행렬                            │
//  │   determinant(m)                      // 행렬식 (2x2, 3x3, 4x4)              │
//  │   // 역행렬은 직접 구현 필요                                                  │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                            비교/논리 함수                                      │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   min(a, b), max(a, b)                // 최소/최대값                          │
//  │   abs(x)                              // 절대값                               │
//  │   sign(x)                             // 부호: -1, 0, 1                       │
//  │   floor(x), ceil(x), round(x)         // 반올림 함수들                        │
//  │   fract(x)                            // 소수 부분: x - floor(x)              │
//  │   fmod(x, y)                          // 부동소수점 나머지                    │
//  │   select(a, b, c)                     // c ? b : a (분기 없는 조건 선택)      │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//  제8장: Metal 4 셰이더 특징
//  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
//  Metal 4에서는 셰이더 작성 방식에 몇 가지 변화가 있습니다.
//
//  ┌───────────────────────────────────────────────────────────────────────────────┐
//  │                      Metal 4 vs 기존 Metal 셰이더 비교                         │
//  ├───────────────────────────────────────────────────────────────────────────────┤
//  │                                                                               │
//  │   1. Argument Table과 GPU Address:                                           │
//  │   ─────────────────────────────────                                           │
//  │                                                                               │
//  │   기존 Metal:                                                                 │
//  │   버퍼를 인덱스로 바인딩                                                       │
//  │                                                                               │
//  │   // Swift                                                                    │
//  │   renderEncoder.setVertexBuffer(vertices, offset: 0, index: 0)               │
//  │   renderEncoder.setVertexBuffer(uniforms, offset: 0, index: 1)               │
//  │                                                                               │
//  │   // MSL                                                                      │
//  │   vertex VertexOut shader(                                                    │
//  │       const device Vertex* vertices [[buffer(0)]],                            │
//  │       const device Uniforms* uniforms [[buffer(1)]]                           │
//  │   )                                                                           │
//  │                                                                               │
//  │                                                                               │
//  │   Metal 4:                                                                    │
//  │   GPU 주소를 Argument Table에 설정                                            │
//  │                                                                               │
//  │   // Swift                                                                    │
//  │   argumentTable.setAddress(vertices.gpuAddress, index: 0)                    │
//  │   argumentTable.setAddress(uniforms.gpuAddress, index: 1)                    │
//  │   renderEncoder.setArgumentTable(argumentTable, stages: .vertex)             │
//  │                                                                               │
//  │   // MSL (동일하게 작성 가능)                                                  │
//  │   vertex VertexOut shader(                                                    │
//  │       const device Vertex* vertices [[buffer(0)]],                            │
//  │       const device Uniforms* uniforms [[buffer(1)]]                           │
//  │   )                                                                           │
//  │                                                                               │
//  │   장점:                                                                       │
//  │   • GPU 주소 기반으로 더 유연한 리소스 관리                                    │
//  │   • 런타임에 버퍼 주소 변경 가능                                              │
//  │   • 간접 버퍼 접근 지원                                                       │
//  │                                                                               │
//  └───────────────────────────────────────────────────────────────────────────────┘
//
//
//  ┌─────────────────────────────────────────────────────────────────┐
//  │                     렌더링 파이프라인 개요                         │
//  ├─────────────────────────────────────────────────────────────────┤
//  │                                                                 │
//  │   [Vertex Data]  ──▶  [Vertex Shader]  ──▶  [Rasterizer]       │
//  │        │                    │                    │              │
//  │        │                    ▼                    ▼              │
//  │        │              클립 공간 좌표        프래그먼트 생성        │
//  │        │              (Clip Space)                              │
//  │        │                                         │              │
//  │        │                                         ▼              │
//  │        │                              [Fragment Shader]         │
//  │        │                                         │              │
//  │        │                                         ▼              │
//  │        └─────────────────────────────────▶  [Frame Buffer]      │
//  │                                                                 │
//  └─────────────────────────────────────────────────────────────────┘
//
//  좌표계 설명 (Left-Hand Coordinate System):
//  ──────────────────────────────────────────
//
//       +Y (위)
//        │
//        │
//        │
//        │
//        └──────────── +X (오른쪽)
//       ╱
//      ╱
//     ╱
//    +Z (화면 안쪽, 멀어지는 방향)
//
//  - X축: 오른쪽이 양의 방향
//  - Y축: 위쪽이 양의 방향
//  - Z축: 화면 안쪽(멀어지는 방향)이 양의 방향 (왼손 좌표계의 특징)
//
//  Metal 4의 주요 변경사항:
//  ─────────────────────────
//  Metal 4에서는 Argument Table을 통해 버퍼를 바인딩하므로,
//  셰이더에서는 device 포인터를 통해 버퍼에 접근합니다.
//  이는 기존의 [[buffer(n)]] 어트리뷰트 방식보다 더 유연한 리소스 바인딩을 가능하게 합니다.
//

#include <metal_stdlib>
using namespace metal;

// ============================================================================
// MARK: - 데이터 구조체 정의
// ============================================================================

/// 버텍스 데이터 구조체
///
/// GPU 메모리에 저장된 각 버텍스(정점)의 데이터를 정의합니다.
/// Swift 측의 `Vertex` 구조체와 메모리 레이아웃이 일치해야 합니다.
///
/// 메모리 레이아웃 (28 bytes per vertex):
/// ┌────────────────────────────────────────────────────────────┐
/// │ position (float3)  │ color (float4)                       │
/// │ 12 bytes           │ 16 bytes                             │
/// │ [x, y, z]          │ [r, g, b, a]                         │
/// └────────────────────────────────────────────────────────────┘
///
/// - Note: float3는 실제로 16바이트로 정렬될 수 있으므로,
///         Swift 측에서 SIMD3<Float>를 사용할 때 stride를 확인해야 합니다.
struct Vertex {
    /// 3D 공간에서의 버텍스 위치 (로컬/모델 좌표계)
    /// - x: 좌우 위치 (-1.0 ~ 1.0, 왼쪽이 음수)
    /// - y: 상하 위치 (-1.0 ~ 1.0, 아래가 음수)
    /// - z: 깊이 위치 (0.0 ~ 1.0, 가까운 곳이 0)
    float3 position;

    /// 버텍스 색상 (RGBA 형식)
    /// - r: 빨간색 강도 (0.0 ~ 1.0)
    /// - g: 초록색 강도 (0.0 ~ 1.0)
    /// - b: 파란색 강도 (0.0 ~ 1.0)
    /// - a: 불투명도 (0.0 = 투명, 1.0 = 불투명)
    float4 color;
};

/// 버텍스 셰이더 출력 / 프래그먼트 셰이더 입력 구조체
///
/// 버텍스 셰이더에서 처리된 결과를 프래그먼트 셰이더로 전달합니다.
/// GPU의 래스터라이저가 이 데이터를 보간(interpolation)하여
/// 각 프래그먼트(픽셀 후보)에 대한 값을 생성합니다.
///
/// 보간 과정 예시 (삼각형 내부의 한 점 P):
/// ┌─────────────────────────────────────────────┐
/// │            V0 (빨강)                         │
/// │              ╱╲                              │
/// │             ╱  ╲                             │
/// │            ╱ P  ╲  ← P의 색상은 V0, V1, V2의 │
/// │           ╱      ╲    가중 평균으로 계산됨     │
/// │          ╱________╲                          │
/// │    V2 (파랑)    V1 (초록)                     │
/// └─────────────────────────────────────────────┘
struct VertexOut {
    /// 클립 공간(Clip Space) 좌표
    ///
    /// [[position]] 어트리뷰트는 이 값이 버텍스의 최종 위치임을 GPU에 알립니다.
    /// GPU는 이 좌표를 사용하여:
    /// 1. 원근 분할 (Perspective Division): xyz / w
    /// 2. 뷰포트 변환 (Viewport Transform): NDC → 화면 좌표
    /// 3. 클리핑 (Clipping): 화면 밖의 지오메트리 제거
    ///
    /// 클립 공간 좌표 범위:
    /// - x: -w ~ +w (나중에 -1 ~ +1로 정규화)
    /// - y: -w ~ +w (나중에 -1 ~ +1로 정규화)
    /// - z: 0 ~ +w  (Metal의 깊이 범위는 0 ~ 1)
    /// - w: 원근 분할에 사용되는 동차 좌표
    float4 position [[position]];

    /// 보간된 버텍스 색상
    ///
    /// 래스터라이저가 삼각형의 세 버텍스 색상을 무게중심 좌표
    /// (Barycentric Coordinates)를 사용하여 부드럽게 보간합니다.
    /// 이를 통해 그라디언트 효과가 자연스럽게 생성됩니다.
    float4 color;
};

/// 유니폼(Uniform) 데이터 구조체
///
/// 모든 버텍스에 동일하게 적용되는 변환 행렬들을 포함합니다.
/// "Uniform"이라는 이름은 모든 셰이더 호출에서 값이 균일(uniform)하기 때문입니다.
///
/// 변환 파이프라인:
/// ┌─────────────────────────────────────────────────────────────────────────┐
/// │                                                                         │
/// │   [로컬 좌표]  ─── Model ───▶  [월드 좌표]  ─── View ───▶  [뷰 좌표]    │
/// │   (Local)       Matrix        (World)       Matrix       (View/Eye)    │
/// │                                                                         │
/// │                                    │                                    │
/// │                                    ▼                                    │
/// │                              Projection                                 │
/// │                                Matrix                                   │
/// │                                    │                                    │
/// │                                    ▼                                    │
/// │                              [클립 좌표]                                 │
/// │                              (Clip Space)                               │
/// │                                                                         │
/// └─────────────────────────────────────────────────────────────────────────┘
///
/// 메모리 레이아웃 (192 bytes):
/// - modelMatrix:      64 bytes (4x4 floats)
/// - viewMatrix:       64 bytes (4x4 floats)
/// - projectionMatrix: 64 bytes (4x4 floats)
struct Uniforms {
    /// 모델 변환 행렬 (Model Matrix)
    ///
    /// 오브젝트의 로컬 좌표를 월드 좌표로 변환합니다.
    /// 이 행렬은 다음 변환들의 조합일 수 있습니다:
    /// - 이동 (Translation): 오브젝트 위치 이동
    /// - 회전 (Rotation): 오브젝트 방향 변경
    /// - 스케일 (Scale): 오브젝트 크기 변경
    ///
    /// 예시 (Y축 회전):
    /// ┌                    ┐
    /// │ cos(θ)  0  -sin(θ) 0 │
    /// │   0     1     0    0 │
    /// │ sin(θ)  0   cos(θ) 0 │
    /// │   0     0     0    1 │
    /// └                    ┘
    float4x4 modelMatrix;

    /// 뷰 변환 행렬 (View Matrix)
    ///
    /// 월드 좌표를 카메라(눈) 기준 좌표로 변환합니다.
    /// 실제로는 카메라를 원점에 고정하고 전체 월드를 역방향으로 변환합니다.
    ///
    /// lookAt 함수로 생성되며 다음을 정의합니다:
    /// - eye: 카메라 위치
    /// - target: 카메라가 바라보는 지점
    /// - up: 카메라의 위쪽 방향
    ///
    /// 왼손 좌표계에서 카메라는 +Z 방향을 바라봅니다.
    float4x4 viewMatrix;

    /// 투영 변환 행렬 (Projection Matrix)
    ///
    /// 3D 뷰 좌표를 2D 클립 좌표로 변환합니다.
    /// 원근 투영(Perspective Projection)을 사용하여
    /// 멀리 있는 물체가 작게 보이는 효과를 구현합니다.
    ///
    /// 원근 투영의 시각적 효과:
    /// ┌─────────────────────────────────────┐
    /// │     Near Plane    Far Plane         │
    /// │         │             │             │
    /// │    ┌────┼────┐   ┌────┼────┐        │
    /// │    │    │    │   │    │    │        │
    /// │ Eye ════╪════════════╪════ ▶ +Z     │
    /// │    │    │    │   │    │    │        │
    /// │    └────┼────┘   └────┼────┘        │
    /// │         │             │             │
    /// │    (크게 보임)    (작게 보임)         │
    /// └─────────────────────────────────────┘
    ///
    /// 주요 파라미터:
    /// - FOV (Field of View): 시야각 (라디안)
    /// - Aspect Ratio: 화면 가로/세로 비율
    /// - Near/Far: 클리핑 평면 거리
    float4x4 projectionMatrix;
};


// ============================================================================
// MARK: - 버텍스 셰이더 (Vertex Shader)
// ============================================================================

/// 버텍스 셰이더 함수
///
/// GPU에서 각 버텍스(정점)마다 한 번씩 실행되며,
/// 3D 모델 좌표를 화면에 표시할 수 있는 클립 좌표로 변환합니다.
///
/// ## 실행 흐름
///
/// ```
/// 각 버텍스에 대해:
/// 1. vertex_id를 사용하여 버텍스 데이터 읽기
/// 2. MVP 행렬 계산 (Projection × View × Model)
/// 3. 버텍스 위치에 MVP 행렬 적용
/// 4. 변환된 위치와 색상을 VertexOut으로 출력
/// ```
///
/// ## 좌표 변환 상세
///
/// MVP 행렬 적용 순서 (오른쪽에서 왼쪽으로 읽음):
/// ```
/// clipPosition = projectionMatrix × viewMatrix × modelMatrix × localPosition
///              = P × V × M × v
/// ```
///
/// 각 단계의 좌표 공간:
/// 1. localPosition (float4): 모델의 로컬 좌표 (w=1.0으로 동차좌표 생성)
/// 2. M × v: 월드 좌표 (모델이 월드에 배치된 위치)
/// 3. V × M × v: 뷰 좌표 (카메라 기준 좌표)
/// 4. P × V × M × v: 클립 좌표 (투영 적용)
///
/// ## Metal 4 특징
///
/// Metal 4에서는 `[[buffer(n)]]` 대신 device 포인터를 사용합니다.
/// Argument Table을 통해 버퍼의 GPU 주소가 전달되므로,
/// 셰이더는 해당 주소에서 직접 데이터를 읽습니다.
///
/// - Parameters:
///   - vertexID: 현재 처리 중인 버텍스의 인덱스 (0부터 시작)
///               [[vertex_id]] 어트리뷰트로 GPU가 자동 제공
///   - vertices: 버텍스 배열에 대한 디바이스 포인터
///               Argument Table의 index 0에 바인딩된 버퍼
///   - uniforms: 유니폼 데이터에 대한 디바이스 포인터
///               Argument Table의 index 1에 바인딩된 버퍼
///
/// - Returns: 변환된 버텍스 데이터 (위치 + 색상)
///
/// - Note: 이 셰이더는 삼각형의 3개 버텍스에 대해 각각 한 번씩,
///         총 3번 실행됩니다.
vertex VertexOut vertexShader(
    uint vertexID [[vertex_id]],
    const device Vertex* vertices [[buffer(0)]],
    const device Uniforms* uniforms [[buffer(1)]]
) {
    // 출력 구조체 초기화
    VertexOut out;

    // ────────────────────────────────────────────────────────────────
    // MVP (Model-View-Projection) 행렬 계산
    // ────────────────────────────────────────────────────────────────
    //
    // 행렬 곱셈 순서가 중요합니다!
    // GPU에서의 행렬 곱셈은 오른쪽에서 왼쪽으로 적용됩니다:
    //
    //   mvp = P × V × M
    //
    // 버텍스에 적용할 때:
    //   result = mvp × vertex = P × (V × (M × vertex))
    //
    // 이는 다음 순서로 변환됨을 의미합니다:
    //   1. Model: 로컬 → 월드
    //   2. View: 월드 → 카메라
    //   3. Projection: 카메라 → 클립
    //
    float4x4 mvp = uniforms->projectionMatrix * uniforms->viewMatrix * uniforms->modelMatrix;

    // ────────────────────────────────────────────────────────────────
    // 버텍스 위치 변환
    // ────────────────────────────────────────────────────────────────
    //
    // float3 → float4 변환:
    // - w = 1.0을 추가하여 동차 좌표(Homogeneous Coordinates)로 만듦
    // - 동차 좌표는 행렬 곱셈으로 이동(translation)을 표현할 수 있게 함
    //
    // 변환 후 클립 좌표의 의미:
    // - x, y: 화면 상의 위치 (나중에 w로 나눠서 NDC로 변환)
    // - z: 깊이 값 (깊이 테스트에 사용)
    // - w: 원근 분할을 위한 값 (보통 카메라까지의 거리와 관련)
    //
    out.position = mvp * float4(vertices[vertexID].position, 1.0);

    // ────────────────────────────────────────────────────────────────
    // 버텍스 색상 전달 (Pass-through)
    // ────────────────────────────────────────────────────────────────
    //
    // 색상은 변환 없이 그대로 전달됩니다.
    // 래스터라이저가 삼각형 내부의 각 픽셀에 대해
    // 세 버텍스의 색상을 자동으로 보간합니다.
    //
    out.color = vertices[vertexID].color;

    return out;
}


// ============================================================================
// MARK: - 프래그먼트 셰이더 (Fragment Shader)
// ============================================================================

/// 프래그먼트 셰이더 함수
///
/// GPU에서 래스터화된 각 프래그먼트(픽셀 후보)마다 실행되며,
/// 최종 픽셀 색상을 결정합니다.
///
/// ## 프래그먼트란?
///
/// 프래그먼트는 잠재적인 픽셀입니다. 삼각형이 화면의 픽셀 그리드와
/// 교차하는 모든 위치에서 프래그먼트가 생성됩니다.
///
/// ```
/// 삼각형과 픽셀 그리드:
/// ┌───┬───┬───┬───┬───┐
/// │   │ ▲ │   │   │   │  ▲ = 삼각형 꼭짓점
/// ├───┼─╱─┼───┼───┼───┤
/// │  ╱│███│╲  │   │   │  ███ = 생성된 프래그먼트
/// ├─╱─┼───┼─╲─┼───┼───┤
/// │███│███│███│╲  │   │  각 프래그먼트마다
/// ├───┼───┼───┼─╲─┼───┤  이 셰이더가 실행됨
/// │   │   │   │  ╲│   │
/// └───┴───┴───┴───┴───┘
/// ```
///
/// ## 색상 보간
///
/// 입력으로 받는 `in.color`는 버텍스 셰이더에서 출력된 세 버텍스의
/// 색상이 현재 프래그먼트의 위치에 맞게 보간된 값입니다.
///
/// 보간 공식 (무게중심 좌표 사용):
/// ```
/// color = w0 × color0 + w1 × color1 + w2 × color2
/// ```
/// 여기서 w0 + w1 + w2 = 1.0
///
/// ## 이 셰이더가 하는 일
///
/// 현재는 단순히 보간된 색상을 그대로 출력합니다.
/// 더 복잡한 셰이더에서는 여기서:
/// - 텍스처 샘플링
/// - 조명 계산 (Phong, PBR 등)
/// - 노말 매핑
/// - 그림자 계산
/// - 후처리 효과
/// 등을 수행할 수 있습니다.
///
/// - Parameter in: 래스터라이저가 보간한 버텍스 데이터
///                 [[stage_in]] 어트리뷰트는 이것이 이전 스테이지의
///                 출력임을 나타냅니다.
///
/// - Returns: 최종 픽셀 색상 (RGBA)
///            이 값이 프레임 버퍼에 기록됩니다.
///
/// - Note: 삼각형 내부의 모든 픽셀에 대해 실행되므로,
///         작은 삼각형이라도 수백~수천 번 실행될 수 있습니다.
fragment float4 fragmentShader(VertexOut in [[stage_in]]) {
    // ────────────────────────────────────────────────────────────────
    // 최종 색상 출력
    // ────────────────────────────────────────────────────────────────
    //
    // 보간된 색상을 그대로 반환합니다.
    // 결과적으로 세 버텍스(빨강, 초록, 파랑)의 색상이
    // 삼각형 전체에 걸쳐 부드럽게 그라디언트로 표현됩니다.
    //
    // 출력 형식: float4(R, G, B, A)
    // - 각 채널은 0.0 ~ 1.0 범위
    // - 프레임 버퍼의 픽셀 포맷에 맞게 자동 변환됨
    //   (예: BGRA8Unorm_sRGB의 경우 0~255 정수로 변환)
    //
    return in.color;
}
